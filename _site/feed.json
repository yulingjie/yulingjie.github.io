{
    "version": "https://jsonfeed.org/version/1",
    "title": "只砖片瓦",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "一些归纳和总结",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/05/22/unity-ugui-particle",
            "title": "unity_ugui_particle",
            "summary": null,
            "content_text": "最近在整理以前的代码，看到以前使用UGUI刷新ParticleSystem的一些代码，稍微整理下了。背景主要是，制作UI的时候，会遇到一些游戏UI上特效层级遮挡关系，UGUI这边传统的做法无非canvas，sort layer+sort order, z值修改，略微麻烦，所以在考虑有没有更好点的方法，当时写下了这个方法，现在回首看看，还是有些问题的。源码using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using UnityEngine;using UnityEngine.UI;[ExecuteInEditMode]class UIBillboardParticle : Graphic{    private Canvas _canvas;    private ParticleSystem _pSystem;    private ParticleSystemRenderer _pRenderer;    private ParticleSystem.Particle[] _particles;    private Mesh _mesh;    private Texture _curTexture;    private UIVertex[] _quad = new UIVertex[4];    protected override void Awake()    {        base.Awake();        _canvas = MaskUtilities.FindRootSortOverrideCanvas(transform).GetComponent&lt;Canvas&gt;();        _pSystem = GetComponentInChildren&lt;ParticleSystem&gt;();        _pRenderer = _pSystem.GetComponent&lt;ParticleSystemRenderer&gt;();        if (_pRenderer != null)        {            _pRenderer.enabled = false;        }        var mat = _pRenderer.sharedMaterial;        material = mat;        _curTexture = mat.mainTexture;        _particles = new ParticleSystem.Particle[_pSystem.main.maxParticles];        _mesh = _pRenderer.mesh;    }    public override Texture mainTexture    {        get        {            return _curTexture;        }    }    protected override void OnPopulateMesh(VertexHelper vh)    {        vh.Clear();        int count = _pSystem.GetParticles(_particles);        for (int i = 0; i &lt; count; ++i)        {            var particle = _particles[i];            // transfer position to object space            Vector3 position = Vector3.zero;            if (_pSystem.main.simulationSpace == ParticleSystemSimulationSpace.Local)            {                position = particle.position;            }            else if (_pSystem.main.simulationSpace == ParticleSystemSimulationSpace.World)            {                position = transform.InverseTransformPoint(particle.position);            }            /// calculate correct scale factor            Vector3 scaleFactor = Vector3.one;            if (_pSystem.main.scalingMode == ParticleSystemScalingMode.Local)            {                scaleFactor.x /= _canvas.transform.localScale.x;                scaleFactor.y /= _canvas.transform.localScale.y;                scaleFactor.z /= _canvas.transform.localScale.z;            }            position.x *= scaleFactor.x;            position.y *= scaleFactor.y;            var size = particle.GetCurrentSize3D(_pSystem) * 0.5f;            size.x *= scaleFactor.x;            size.y *= scaleFactor.y;            size.z = 0f;            Color32 color = particle.GetCurrentColor(_pSystem);            var uv = new Vector4(0, 0, 1, 1);            _quad[0] = UIVertex.simpleVert;            _quad[0].color = color;            _quad[0].uv0 = new Vector2(0, 0);            _quad[1] = UIVertex.simpleVert;            _quad[1].color = color;            _quad[1].uv0 = new Vector2(0, 1);            _quad[2] = UIVertex.simpleVert;            _quad[2].color = color;            _quad[2].uv0 = new Vector2(1, 1);            _quad[3] = UIVertex.simpleVert;            _quad[3].color = color;            _quad[3].uv0 = new Vector2(1, 0);            var corner1 = position - size;            var corner2 = position + size;                        _quad[0].position = new Vector2(corner1.x, corner1.y);            _quad[1].position = new Vector2(corner1.x, corner2.y);            _quad[2].position = new Vector2(corner2.x,corner2.y);            _quad[3].position = new Vector2(corner2.x, corner1.y);            vh.AddUIVertexQuad(_quad);        }    }    void Update()    {        _pSystem.Simulate(Time.unscaledDeltaTime, false, false, true);        SetVerticesDirty();        //SetAllDirty();    }}大体思路就是讲粒子面片刷到UI中去，使用canvasrender进行渲染，这样做的确可以方便UI的层级调整。问题问题主要还是出在效率上面吧，未来让OnPopulatedMesh每一帧被调用，于是Update中必须每一帧去SetVerticesDirty，导致Canvas的重新构建。可以看到，此时使用1000个粒子的效率。然后我们使用脚本的方法看下1000个粒子的效率：可以看到，PostLateUpdate.PlayerUpdateCanvases这里会有额外消耗。消耗解析这里需要找下UGUI源码，定位到Graphics-&gt;Rebuild  public virtual void Rebuild(CanvasUpdate update)        {            if (canvasRenderer == null || canvasRenderer.cull)                return;            switch (update)            {                case CanvasUpdate.PreRender:                    if (m_VertsDirty)                    {                        UpdateGeometry();                        m_VertsDirty = false;                    }                    if (m_MaterialDirty)                    {                        UpdateMaterial();                        m_MaterialDirty = false;                    }                    break;            }        }我们可以看到这里每一帧我们都需要UpdateGeometry，而这的确是我们的消耗大头。最终代码定位到canvasRender.SetMesh()，接下来看不到源码了，没什么好的优化想法。猜想理论上这里知识构建一个简单的Mesh，然后去模拟粒子效果，当然，这里需要每一帧去创建Mesh，相比粒子原来的Mesh变换会慢一定，但问题定位目前县搁置吧，以后有机会看到源码再研究下。",
            "content_html": "<p>最近在整理以前的代码，看到以前使用UGUI刷新ParticleSystem的一些代码，稍微整理下了。</p><!--more--><h2 id=\"背景\">背景</h2><p>主要是，制作UI的时候，会遇到一些游戏UI上特效层级遮挡关系，UGUI这边传统的做法无非canvas，sort layer+sort order, z值修改，略微麻烦，所以在考虑有没有更好点的方法，当时写下了这个方法，现在回首看看，还是有些问题的。</p><h2 id=\"源码\">源码</h2><pre><code>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using UnityEngine;using UnityEngine.UI;[ExecuteInEditMode]class UIBillboardParticle : Graphic{    private Canvas _canvas;    private ParticleSystem _pSystem;    private ParticleSystemRenderer _pRenderer;    private ParticleSystem.Particle[] _particles;    private Mesh _mesh;    private Texture _curTexture;    private UIVertex[] _quad = new UIVertex[4];    protected override void Awake()    {        base.Awake();        _canvas = MaskUtilities.FindRootSortOverrideCanvas(transform).GetComponent&lt;Canvas&gt;();        _pSystem = GetComponentInChildren&lt;ParticleSystem&gt;();        _pRenderer = _pSystem.GetComponent&lt;ParticleSystemRenderer&gt;();        if (_pRenderer != null)        {            _pRenderer.enabled = false;        }        var mat = _pRenderer.sharedMaterial;        material = mat;        _curTexture = mat.mainTexture;        _particles = new ParticleSystem.Particle[_pSystem.main.maxParticles];        _mesh = _pRenderer.mesh;    }    public override Texture mainTexture    {        get        {            return _curTexture;        }    }    protected override void OnPopulateMesh(VertexHelper vh)    {        vh.Clear();        int count = _pSystem.GetParticles(_particles);        for (int i = 0; i &lt; count; ++i)        {            var particle = _particles[i];            // transfer position to object space            Vector3 position = Vector3.zero;            if (_pSystem.main.simulationSpace == ParticleSystemSimulationSpace.Local)            {                position = particle.position;            }            else if (_pSystem.main.simulationSpace == ParticleSystemSimulationSpace.World)            {                position = transform.InverseTransformPoint(particle.position);            }            /// calculate correct scale factor            Vector3 scaleFactor = Vector3.one;            if (_pSystem.main.scalingMode == ParticleSystemScalingMode.Local)            {                scaleFactor.x /= _canvas.transform.localScale.x;                scaleFactor.y /= _canvas.transform.localScale.y;                scaleFactor.z /= _canvas.transform.localScale.z;            }            position.x *= scaleFactor.x;            position.y *= scaleFactor.y;            var size = particle.GetCurrentSize3D(_pSystem) * 0.5f;            size.x *= scaleFactor.x;            size.y *= scaleFactor.y;            size.z = 0f;            Color32 color = particle.GetCurrentColor(_pSystem);            var uv = new Vector4(0, 0, 1, 1);            _quad[0] = UIVertex.simpleVert;            _quad[0].color = color;            _quad[0].uv0 = new Vector2(0, 0);            _quad[1] = UIVertex.simpleVert;            _quad[1].color = color;            _quad[1].uv0 = new Vector2(0, 1);            _quad[2] = UIVertex.simpleVert;            _quad[2].color = color;            _quad[2].uv0 = new Vector2(1, 1);            _quad[3] = UIVertex.simpleVert;            _quad[3].color = color;            _quad[3].uv0 = new Vector2(1, 0);            var corner1 = position - size;            var corner2 = position + size;                        _quad[0].position = new Vector2(corner1.x, corner1.y);            _quad[1].position = new Vector2(corner1.x, corner2.y);            _quad[2].position = new Vector2(corner2.x,corner2.y);            _quad[3].position = new Vector2(corner2.x, corner1.y);            vh.AddUIVertexQuad(_quad);        }    }    void Update()    {        _pSystem.Simulate(Time.unscaledDeltaTime, false, false, true);        SetVerticesDirty();        //SetAllDirty();    }}</code></pre><p>大体思路就是讲粒子面片刷到UI中去，使用canvasrender进行渲染，这样做的确可以方便UI的层级调整。</p><h2 id=\"问题\">问题</h2><p>问题主要还是出在效率上面吧，未来让OnPopulatedMesh每一帧被调用，于是Update中必须每一帧去SetVerticesDirty，导致Canvas的重新构建。<img src=\"assets/ugui_particlesystem/2020-05-23-080746.png\" alt=\"non_script\" />可以看到，此时使用1000个粒子的效率。然后我们使用脚本的方法看下1000个粒子的效率：<img src=\"assets/ugui_particlesystem/2020-05-23-081126.png\" alt=\"with_script\" />可以看到，PostLateUpdate.PlayerUpdateCanvases这里会有额外消耗。</p><h2 id=\"消耗解析\">消耗解析</h2><p>这里需要找下UGUI源码，定位到Graphics-&gt;Rebuild</p><pre><code>  public virtual void Rebuild(CanvasUpdate update)        {            if (canvasRenderer == null || canvasRenderer.cull)                return;            switch (update)            {                case CanvasUpdate.PreRender:                    if (m_VertsDirty)                    {                        UpdateGeometry();                        m_VertsDirty = false;                    }                    if (m_MaterialDirty)                    {                        UpdateMaterial();                        m_MaterialDirty = false;                    }                    break;            }        }</code></pre><p>我们可以看到这里每一帧我们都需要UpdateGeometry，而这的确是我们的消耗大头。最终代码定位到<code>canvasRender.SetMesh()</code>，接下来看不到源码了，没什么好的优化想法。</p><h2 id=\"猜想\">猜想</h2><p>理论上这里知识构建一个简单的Mesh，然后去模拟粒子效果，当然，这里需要每一帧去创建Mesh，相比粒子原来的Mesh变换会慢一定，但问题定位目前县搁置吧，以后有机会看到源码再研究下。</p>",
            "url": "http://localhost:4000/2020/05/22/unity-ugui-particle",
            
            
            
            "tags": ["unity","ugui","particlesystem"],
            
            "date_published": "2020-05-22T00:00:00+08:00",
            "date_modified": "2020-05-22T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/19/sereja-and-brackets",
            "title": "C.Sereja and Brackets",
            "summary": null,
            "content_text": "趁热打铁，深入理解segment tree算法。参考文章链接。问题描述  Sereja has a bracket sequence s1, s2, …, sn, or, in other words, a string s of length n, consisting of characters “(“ and “)”.  Sereja needs to answer m queries, each of them is described by two integers li, ri (1 ≤ li ≤ ri ≤ n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence sli, sli + 1, …, sri. Help Sereja answer all queries.  You can find the definitions for a subsequence and a correct bracket sequence in the notes.  InputThe first line contains a sequence of characters s1, s2, …, sn (1 ≤ n ≤ 106) without any spaces. Each character is either a “(“ or a “)”. The second line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th query.  OutputPrint the answer to each question on a single line. Print the answers in the order they go in the input.解答首先，我们看下标准的segment tree函数:void build(int id =1, int l =0, int r = n){    if(r - l&lt; 2)    {        s[id]= a[l];        return;    }    int mid = (l + r)/2;    build(id *2 , l ,mid);    build(id*2+1,mid,r);    s[id] = s[id *2] + s[id*2 +1];}int sum(int x, int y, int id=1, int l =0, int r=n){    if(x &gt;=r || l&gt;=y) return 0;    if(x&lt;=l &amp;&amp;  r &lt;= y) return s[id];    int mid =(l + r)/2;    return sum(x,y,id*2,l, mid)    + sum(x,y,id*2+1,mid,r);}vector&lt;s&gt;;void split(int x, int y,int n){    int l = x;    int r = y;    for(l +=n, r+=n ; l&lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)    {        if(l&amp;1) s.push_back(l++);        if(r&amp;1) s.push_back(--r);    }}我们通过完全二叉树储存区间，查询的时候，查询这个区间的最大子节点所储存的值。这里同样，为了实现括号配对，我们对每个节点储存三种数据:  t[x], x节点所有的配对的数目;  o[x], x节点所代表的区间上，未配对的左括号数；  c[x], x节点所代表的区间上,为配对的右括号数；而每次合并子节点时：tmp = min(o[2*x], c[2*x +1])t[x] = t[2*x] + t[2*x + 1] + tmpo[x] = o[2*x] + o[2*x +1] - tmpc[x] = c[2*x] + c[2*x + 1] - tmp类似的，我们可以得出build函数：void update(int id){    int tmp = min(o[2*id], c[2*id +1]);    t[id] = t[2*id] + t[2*id + 1] + tmp;    o[id] = o[2*id] + o[2*id +1] - tmp;    c[id] = c[2*id] + c[2*id + 1] - tmp;}void build(int id = 1, int l = 0, int r = n){    if(r - l &lt; 2)    {        if(s[l] == '(')        {            o[l] = 1;        }        else        {            c[l] = 1;        }        return;    }    int mid = ( l + r) /2;    build(2 * id,l,mid);    build(2 * id +1,mid, r);    update(id);}对应的查询函数：typedef pair&lt;int, int&gt;pii;typedef pair&lt;int,pii&gt; node;node segment(int x, int y,int id=1, int l =0, int r = n){    if( l&gt;= y || x &gt;= r) return node(0,pii(0,0));    if(x &lt;= l &amp;&amp; r&lt;= y)    {        return node(t[id], pii(o[id],c[id]));    }    int mid = (l + r)/2;    node a = segment(x, y, 2 * id, l, mid);    node b = segment(x,y,2*id + 1,mid,r);    int temp = min(a.y.x,b.y.y);    int T = a.x + b.x + temp;    int O = a.y.x + b.y.x - temp;    int C = a.y.y + b.y.y - temp;    return node(T,pii(O,C));}完工。",
            "content_html": "<p>趁热打铁，深入理解segment tree算法。参考文章<a href=\"https://codeforces.com/blog/entry/15890\">链接</a>。</p><h2 id=\"问题描述\">问题描述</h2><blockquote>  <p>Sereja has a bracket sequence s1, s2, …, sn, or, in other words, a string s of length n, consisting of characters “(“ and “)”.</p>  <p>Sereja needs to answer m queries, each of them is described by two integers li, ri (1 ≤ li ≤ ri ≤ n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence sli, sli + 1, …, sri. Help Sereja answer all queries.</p>  <p>You can find the definitions for a subsequence and a correct bracket sequence in the notes.</p>  <p>InputThe first line contains a sequence of characters s1, s2, …, sn (1 ≤ n ≤ 106) without any spaces. Each character is either a “(“ or a “)”. The second line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th query.</p>  <p>OutputPrint the answer to each question on a single line. Print the answers in the order they go in the input.</p></blockquote><h2 id=\"解答\">解答</h2><p>首先，我们看下标准的segment tree函数:</p><pre><code>void build(int id =1, int l =0, int r = n){    if(r - l&lt; 2)    {        s[id]= a[l];        return;    }    int mid = (l + r)/2;    build(id *2 , l ,mid);    build(id*2+1,mid,r);    s[id] = s[id *2] + s[id*2 +1];}int sum(int x, int y, int id=1, int l =0, int r=n){    if(x &gt;=r || l&gt;=y) return 0;    if(x&lt;=l &amp;&amp;  r &lt;= y) return s[id];    int mid =(l + r)/2;    return sum(x,y,id*2,l, mid)    + sum(x,y,id*2+1,mid,r);}vector&lt;s&gt;;void split(int x, int y,int n){    int l = x;    int r = y;    for(l +=n, r+=n ; l&lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)    {        if(l&amp;1) s.push_back(l++);        if(r&amp;1) s.push_back(--r);    }}</code></pre><p>我们通过完全二叉树储存区间，查询的时候，查询这个区间的最大子节点所储存的值。</p><p>这里同样，为了实现括号配对，我们对每个节点储存三种数据:</p><ul>  <li>t[x], x节点所有的配对的数目;</li>  <li>o[x], x节点所代表的区间上，未配对的左括号数；</li>  <li>c[x], x节点所代表的区间上,为配对的右括号数；</li></ul><p>而每次合并子节点时：</p><pre><code>tmp = min(o[2*x], c[2*x +1])t[x] = t[2*x] + t[2*x + 1] + tmpo[x] = o[2*x] + o[2*x +1] - tmpc[x] = c[2*x] + c[2*x + 1] - tmp</code></pre><p>类似的，我们可以得出build函数：</p><pre><code>void update(int id){    int tmp = min(o[2*id], c[2*id +1]);    t[id] = t[2*id] + t[2*id + 1] + tmp;    o[id] = o[2*id] + o[2*id +1] - tmp;    c[id] = c[2*id] + c[2*id + 1] - tmp;}void build(int id = 1, int l = 0, int r = n){    if(r - l &lt; 2)    {        if(s[l] == '(')        {            o[l] = 1;        }        else        {            c[l] = 1;        }        return;    }    int mid = ( l + r) /2;    build(2 * id,l,mid);    build(2 * id +1,mid, r);    update(id);}</code></pre><p>对应的查询函数：</p><pre><code>typedef pair&lt;int, int&gt;pii;typedef pair&lt;int,pii&gt; node;node segment(int x, int y,int id=1, int l =0, int r = n){    if( l&gt;= y || x &gt;= r) return node(0,pii(0,0));    if(x &lt;= l &amp;&amp; r&lt;= y)    {        return node(t[id], pii(o[id],c[id]));    }    int mid = (l + r)/2;    node a = segment(x, y, 2 * id, l, mid);    node b = segment(x,y,2*id + 1,mid,r);    int temp = min(a.y.x,b.y.y);    int T = a.x + b.x + temp;    int O = a.y.x + b.y.x - temp;    int C = a.y.y + b.y.y - temp;    return node(T,pii(O,C));}</code></pre><p>完工。</p>",
            "url": "http://localhost:4000/2020/01/19/sereja-and-brackets",
            
            
            
            
            
            "date_published": "2020-01-19T00:00:00+08:00",
            "date_modified": "2020-01-19T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/16/segmenttree",
            "title": "segment tree",
            "summary": null,
            "content_text": "本文的目的，归纳整理segment tree这个数据结构的使用。参考codeforces的链接1和链接2以及链接3。基本结构先考虑2的k次幂,这个比较好理解。考虑数组[0,16)：!operation 1这里使用完全二叉树来存数据，对任意一个节点[l,r)都有指向[l,(l+r)/2)和[(l+r)/2,r)的子节点。由于是使用数组储存完全二叉树的情况，对于序号为k的节点，其字节点指向序号为k2和k2 +1的节点。split对任意一段区间[x,y)记为S，我们需要将这个区间分割到相应的节点上；比如说对于区间[3,10),我们应当将这个区间分割到节点19(3)、节点5([4,8))和节点12([8,10)).这样，我们做运算的时候，只需要动这三个节点就好了。//递归版本vector&lt;s&gt;;void split(int x, int y, int id =1,int l =0, int r = n){    if( x &gt;= r or l&gt;=y) return; // [l,r)与[x,y)不相交。    if(x &lt;= l &amp;&amp; r &lt;= y)    {        s.push_back(id);        return;    }    int mid = (l + r)/2;    split(x,y,id*2,l,mid);    split(x,y,id*2+1,mid,r);}递归的代码比较容易理解。我们从树根开始开始二分遍历，只有节点所表示的区间落在[x,y)内部的时候，我们才会采纳这个节点，这个节点不需要进一步细分了。运行时间：直接从示意图上考虑， 我们split区间[l,r)时，[l,r)覆盖的一定是图上高度越高的内部节点，加上不超过两个的叶子节点，那么显然，时间是O(lgn)的。//迭代版本vector&lt;s&gt;;void split(int x, int y,int n){    int l = x;    int r = y;    for(l +=n, r+=n ; l&lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)    {        if(l&amp;1) s.push_back(l++);        if(r&amp;1) s.push_back(--r);    }}迭代版本就难理解多了。迭代版本是自底向上的:    + 首先解析 l+=n, r+=n这句，由于我们是使用数组储存的完全二叉树，那么叶子节点所在的序号即为l+n,r+n.    + 如果l是右子节点，那么l的父亲节点一定包含[x,y)之外的区间，我们应采纳l节点，同时l++;    + 如果r是右子节点，那么[x,y)区间应该落在r节点的左侧，此时我们应当采纳–r这个节点。不管怎么说，这两个版本所要实现的功能是一致的。build//递归版本void build(int id =1, int l =0, int r = n){    if(r - l&lt; 2)    {        s[id]= a[l];        return;    }    int mid = (l + r)/2;    build(id *2 , l ,mid);    build(id*2+1,mid,r);    s[id] = s[id *2] + s[id*2 +1];}// 迭代版本void build(){    // 预先在t[n,2n)间存储了叶节点数据。    for(int i =0; i&lt; n; ++i) scanf(\"%d\", t + n + i);    for(int i = n-1; i&gt;0; --i)    {        t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];        }}modify// 递归版本void modify(int p,int x, int id =1,int l =0, int r= n){    s[id] += x - a[p];    if(r - l&lt; 2)    {        a[p] = x;        return;    }    int mid = (l + r)/2;    if( p&lt; mid)    {        modify(p,x,id*2,l,mid);    }    else    {        modify(p,x,id*2 +1,mid, r);    }}// 迭代版本void modify(int p, int value){    for(t[p +=n] = value; p&gt; 1;p&gt;&gt;=1) t[p&gt;&gt;1] = t[p] + t[p^1];}sum// 递归int sum(int x, int y, int id=1, int l =0, int r=n){    if(x &gt;=r || l&gt;=y) return 0;    if(x&lt;=l &amp;&amp;  r &lt;= y) return s[id];    int mid =(l + r)/2;    return sum(x,y,id*2,l, mid)    + sum(x,y,id*2+1,mid,r);}// 迭代int sum(int l, int r){    int res = 0;    for(l +=n, r+=n; l&lt; r; l &gt;&gt;= 1 , r&gt;&gt;=1)    {        if(l&amp;1) res += t[l++];        if(r&amp;1) res += t[--r];    }    return res;}lazy propagation延迟更新，只在合适的时候才去更新数据。比如说，我们需要将[l,r)这个区间段内的数据统统加x,我们不用逐个将每个数据加x，而是使用一个额外数组记录，在需要的时候，再加上:直接看原版代码不太好理解，这里做个简单的推导。// 对于节点id,区间为[l,r)的所有数据加x// s[id]我们仍然储存这个区间的和，但同时，我们使用lazy[id]来储存需要变更的数据x，但是具体的区间上我们并不去做更新// 事实上，更新x目前止于节点id.void upd(int id,int l,int r,int x){    lazy[id] += x;    //s[id] += (r-l) * x;}void shift(int id, int l, int r){    int mid = (l + r)/2;    upd(id*2,l ,mid, lazy[id]);    upd(id*2+1,mid, r, lazy[id]);    lazy[id] = 0;}// 这里把计算sum的步骤分离出来了// 更新区间数据时，我们只更新对应节点的数据void increase(int x, int y,int v, int id =1,int l = 0,int r = n){    if(x &gt;= r or l &gt;= y) return;    if(x &lt;= l &amp;&amp; r &lt;= y)    {        upd(id, l,r,v); // 同split一样，当节点的区间[l,r)在[x,y)之间时，我们停止向下更新节点数据了        return;     }    // shift(id, l,r); //这里稍微改动下    int mid = (l + r)/2;    increase(x, y, v, id*2,l,mid);    increase(x,y,v,id*2 +1,mid,r);    //s[id] = s[id*2] + s[id*2+1] ; //更新sum数据}在increase时我们标记了一些列需要更新数据的节点，但此时，如果我们直接取s[id]的话，是错误的。考虑此时我们需要调用sum对区间[x,y)进行求值，首先，我们希望，在求值的时候，如果有碰到lazy[id]不为0的节点的话，我们能将这个节点的sum更新了,当然，这个节点的父节点也同样要更新。// 初次尝试int sum(int x, int y,int id= 1, int l =0, int r = n){    if(x &gt;= r || l&gt;=y) return 0;    if(x &lt;=l &amp;&amp; r &lt;=y)     {        s[id] += (lazy[id]* (r-l));        //lazy[id] = 0; 此时节点id的sum值虽然更新了，但是我们并没真的更新每个叶节点，所以我们必须留着lazy[id]        return s[id];    }    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) +        sum(x,y,id*2 +1 ,mid ,r);}可以看到，第一次sum的时候我们成功更新了s[id]的数据，但下次查询之前，lazy[id]必须要清除为0。这意味着，如果某个节点id标记了lazy[id],那么在第一次访问这个节点的s[id]时，我们要同时将s[id]更新到正确的值并且将lazy[id]清除为0.我们对任意一节点分析下lazy[id]的情况：  如果这个节点时叶节点，清楚lazy数据即可；  如果这个节点是某个内部节点的话，记得我们设置lazy的方法，是从根节点往下设置的，那么，我们必须同时去设置这个节点的子节点，即id2 与 id2 +1这两个节点。// 第二版//在更新sum时，我们同时清楚lazy数据int sum(int x, int y, int id=1, int l = 0, int r = n){    if(x &gt;= r|| l &gt;= y) return 0;    if( x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-l));        shift(id,l,r);        return s[id];    }    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);}这样，sum数据的确更新成功，lazy数据也传导到子节点了，但是，我们发现，递归调用的中间路径上，遇到的内部节点的lazy[id]并没用做任何操作，而且，就我们设置lazy的方法来说，我们设置节点的子节点并没有设置lazy数据，换句话说，我们计算sum时，极有可能某个节点明明其父亲节点已经设置过了lazy了，但是由于我们并没有让lazy数据propagate down，在这个子节点上的sum数据获取是错误的。再回到我们第二版的sum函数，我们是自顶向下进行split的，这意味着，我们可以将lazy数据自上向下传播开来。// 我们需要一个只传播lazy数据，但是不重设lazy数据的函数void shiftnoreset(int id, int l, int r){    int mid = (l + r)/2;    upd(id*2,l ,mid, lazy[id]);    upd(id*2+1,mid, r, lazy[id]);    //lazy[id] = 0;}// 第三版，在sum时，我们自顶向下的将lazy数据传播开来int sum(int x,int y ,int id = 1,int l =0 ,int r = n){    if(x &gt;= r ||  l &gt;= y) return 0;    if( x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-l));//只在这里清除了lazy        shift(id,l,r);        return s[id];    }    shiftnoreset(id,l,r);    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);}第三版，虽然我们将lazy数据传播开来了，但是，我们只在最终节点处清楚了lazy数据，对于路径上的其它内部节点，下次再次访问的时候，必然会出现lazy的重复计算的问题。// 第四版，我们将lazy数据传播开来后，计算sum值，更新sum[id],那么此时的lazy[id]就不再有用了，可以方心清零了。int sum(int x, int y, int id=1, int l =0, int r = n){    if(x &gt;= r|| l &gt;= y) return 0;    if(x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-1));        shift(id,l,r);        return s[id];    }    shift(id,l,r);// 我们传播开来lazy后就直接清零了    int mid = (l + r)/2;    s[id] =  sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);    return s[id];}现在我们来研究下原版的代码：void upd(int id, int l, int r, int x){    lazy[id] += x;    s[id] += (r - l) *x;}   void shift(int id,int l, int r){    int mid = (l + r)/2;    upd(id *2 , l ,mid,lazy[id]);    upd(id*2+1,id, r, lazy[id]);    lazy[id] = 0;}void increase(int x,int y,int v, int id=1,int l =0, int r =n){    if(x &gt;= r|| l &gt;= y) return;    if(x&lt;= l || r &lt;= y)     {        upd(id, l,r, v);        return ;    }    shift(id ,l ,r);    int mid = (l + r)/2;    increase(x, y, v, id*2 l ,mid);    increase(x, y ,v, id*2 +1, mid,r);    s[id] = s[id*2] + s[id*2+1];}int sum(int x,int y, int id = 1, int l = 0,  int r = n){    if(x &gt;= r || l &gt;= y) return 0;    if(x&lt;= l &amp;&amp; r &lt;=y ) return s[id];    shift(id,l,r);    int mid = (l+r)/2;    return sum(x, y, id*2, l ,mid) + sum(x, y,id*2 +1, mid,r);}这里使用下图的结构，选择更新[0,8)这个区间+1,来研究下,不妨设原来的所有数据都是0。!operation 2  从根节点[0,16)入手，更新lazy[1]到节点2与节点3。此时lazy[1] =0,所以没有任何变化；  进入左侧子节点[0,8),我们此时进入终止逻辑，更新节点2的lazy数据，lazy[2] = 1,更新sum值，s[2] += (8 - 0) * 1 ;  右侧的不做任何更新，循环停止。我们可以看到，此时，除了终止节点，所有路径上的内部节点均更新过了sum值，且lazy数据均为0。对于终止节点和终止节点之下的节点数据，在没有访问到时，我们可以放心的不管它，而在访问到时，我们进入sum函数逻辑。假设我们需要求sum(2,3)的值。  我们从节点2开始lazy数据一路向下传播，更新节点4与5，5不向下传播了；  节点4继续，更新节点8与节点9，8不继续向下传播了；  节点9注意到，直接返回s[id]了。这几个节点的sum数据在lazy传播过来的同时就更新了，所以这个数据时正确的。于是，我们得到正确的答案。",
            "content_html": "<p>本文的目的，归纳整理segment tree这个数据结构的使用。参考codeforces的<a href=\"https://codeforces.com/blog/entry/15729\">链接1</a>和<a href=\"https://codeforces.com/blog/entry/18051\">链接2</a>以及<a href=\"https://codeforces.com/blog/entry/15890\">链接3</a>。</p><!--more--><h2 id=\"基本结构\">基本结构</h2><p>先考虑2的k次幂,这个比较好理解。考虑数组[0,16)：<a href=\"/assets/segmenttree/basic.png\">!operation 1</a>这里使用完全二叉树来存数据，对任意一个节点[l,r)都有指向[l,(l+r)/2)和[(l+r)/2,r)的子节点。由于是使用数组储存完全二叉树的情况，对于序号为k的节点，其字节点指向序号为k<em>2和k</em>2 +1的节点。</p><h3 id=\"split\">split</h3><p>对任意一段区间[x,y)记为S，我们需要将这个区间分割到相应的节点上；比如说对于区间[3,10),我们应当将这个区间分割到节点19(3)、节点5([4,8))和节点12([8,10)).这样，我们做运算的时候，只需要动这三个节点就好了。</p><pre><code>//递归版本vector&lt;s&gt;;void split(int x, int y, int id =1,int l =0, int r = n){    if( x &gt;= r or l&gt;=y) return; // [l,r)与[x,y)不相交。    if(x &lt;= l &amp;&amp; r &lt;= y)    {        s.push_back(id);        return;    }    int mid = (l + r)/2;    split(x,y,id*2,l,mid);    split(x,y,id*2+1,mid,r);}</code></pre><p>递归的代码比较容易理解。我们从树根开始开始二分遍历，只有节点所表示的区间落在[x,y)内部的时候，我们才会采纳这个节点，这个节点不需要进一步细分了。</p><p>运行时间：直接从示意图上考虑， 我们split区间[l,r)时，[l,r)覆盖的一定是图上高度越高的内部节点，加上不超过两个的叶子节点，那么显然，时间是O(lgn)的。</p><pre><code>//迭代版本vector&lt;s&gt;;void split(int x, int y,int n){    int l = x;    int r = y;    for(l +=n, r+=n ; l&lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)    {        if(l&amp;1) s.push_back(l++);        if(r&amp;1) s.push_back(--r);    }}</code></pre><p>迭代版本就难理解多了。迭代版本是自底向上的:    + 首先解析 <code>l+=n, r+=n</code>这句，由于我们是使用数组储存的完全二叉树，那么叶子节点所在的序号即为l+n,r+n.    + 如果l是右子节点，那么l的父亲节点一定包含[x,y)之外的区间，我们应采纳l节点，同时l++;    + 如果r是右子节点，那么[x,y)区间应该落在r节点的左侧，此时我们应当采纳–r这个节点。</p><p>不管怎么说，这两个版本所要实现的功能是一致的。</p><h3 id=\"build\">build</h3><pre><code>//递归版本void build(int id =1, int l =0, int r = n){    if(r - l&lt; 2)    {        s[id]= a[l];        return;    }    int mid = (l + r)/2;    build(id *2 , l ,mid);    build(id*2+1,mid,r);    s[id] = s[id *2] + s[id*2 +1];}</code></pre><pre><code>// 迭代版本void build(){    // 预先在t[n,2n)间存储了叶节点数据。    for(int i =0; i&lt; n; ++i) scanf(\"%d\", t + n + i);    for(int i = n-1; i&gt;0; --i)    {        t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];        }}</code></pre><h3 id=\"modify\">modify</h3><pre><code>// 递归版本void modify(int p,int x, int id =1,int l =0, int r= n){    s[id] += x - a[p];    if(r - l&lt; 2)    {        a[p] = x;        return;    }    int mid = (l + r)/2;    if( p&lt; mid)    {        modify(p,x,id*2,l,mid);    }    else    {        modify(p,x,id*2 +1,mid, r);    }}</code></pre><pre><code>// 迭代版本void modify(int p, int value){    for(t[p +=n] = value; p&gt; 1;p&gt;&gt;=1) t[p&gt;&gt;1] = t[p] + t[p^1];}</code></pre><h3 id=\"sum\">sum</h3><pre><code>// 递归int sum(int x, int y, int id=1, int l =0, int r=n){    if(x &gt;=r || l&gt;=y) return 0;    if(x&lt;=l &amp;&amp;  r &lt;= y) return s[id];    int mid =(l + r)/2;    return sum(x,y,id*2,l, mid)    + sum(x,y,id*2+1,mid,r);}// 迭代int sum(int l, int r){    int res = 0;    for(l +=n, r+=n; l&lt; r; l &gt;&gt;= 1 , r&gt;&gt;=1)    {        if(l&amp;1) res += t[l++];        if(r&amp;1) res += t[--r];    }    return res;}</code></pre><h3 id=\"lazy-propagation\">lazy propagation</h3><p>延迟更新，只在合适的时候才去更新数据。比如说，我们需要将[l,r)这个区间段内的数据统统加x,我们不用逐个将每个数据加x，而是使用一个额外数组记录，在需要的时候，再加上:</p><p>直接看原版代码不太好理解，这里做个简单的推导。</p><pre><code>// 对于节点id,区间为[l,r)的所有数据加x// s[id]我们仍然储存这个区间的和，但同时，我们使用lazy[id]来储存需要变更的数据x，但是具体的区间上我们并不去做更新// 事实上，更新x目前止于节点id.void upd(int id,int l,int r,int x){    lazy[id] += x;    //s[id] += (r-l) * x;}void shift(int id, int l, int r){    int mid = (l + r)/2;    upd(id*2,l ,mid, lazy[id]);    upd(id*2+1,mid, r, lazy[id]);    lazy[id] = 0;}// 这里把计算sum的步骤分离出来了// 更新区间数据时，我们只更新对应节点的数据void increase(int x, int y,int v, int id =1,int l = 0,int r = n){    if(x &gt;= r or l &gt;= y) return;    if(x &lt;= l &amp;&amp; r &lt;= y)    {        upd(id, l,r,v); // 同split一样，当节点的区间[l,r)在[x,y)之间时，我们停止向下更新节点数据了        return;     }    // shift(id, l,r); //这里稍微改动下    int mid = (l + r)/2;    increase(x, y, v, id*2,l,mid);    increase(x,y,v,id*2 +1,mid,r);    //s[id] = s[id*2] + s[id*2+1] ; //更新sum数据}</code></pre><p>在increase时我们标记了一些列需要更新数据的节点，但此时，如果我们直接取s[id]的话，是错误的。考虑此时我们需要调用sum对区间[x,y)进行求值，首先，我们希望，在求值的时候，如果有碰到lazy[id]不为0的节点的话，我们能将这个节点的sum更新了,当然，这个节点的父节点也同样要更新。</p><pre><code>// 初次尝试int sum(int x, int y,int id= 1, int l =0, int r = n){    if(x &gt;= r || l&gt;=y) return 0;    if(x &lt;=l &amp;&amp; r &lt;=y)     {        s[id] += (lazy[id]* (r-l));        //lazy[id] = 0; 此时节点id的sum值虽然更新了，但是我们并没真的更新每个叶节点，所以我们必须留着lazy[id]        return s[id];    }    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) +        sum(x,y,id*2 +1 ,mid ,r);}</code></pre><p>可以看到，第一次sum的时候我们成功更新了s[id]的数据，但下次查询之前，lazy[id]必须要清除为0。这意味着，如果某个节点id标记了lazy[id],那么在第一次访问这个节点的s[id]时，我们要同时将s[id]更新到正确的值并且将lazy[id]清除为0.我们对任意一节点分析下lazy[id]的情况：</p><ul>  <li>如果这个节点时叶节点，清楚lazy数据即可；</li>  <li>如果这个节点是某个内部节点的话，记得我们设置lazy的方法，是从根节点往下设置的，那么，我们必须同时去设置这个节点的子节点，即id<em>2 与 id</em>2 +1这两个节点。</li></ul><pre><code>// 第二版//在更新sum时，我们同时清楚lazy数据int sum(int x, int y, int id=1, int l = 0, int r = n){    if(x &gt;= r|| l &gt;= y) return 0;    if( x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-l));        shift(id,l,r);        return s[id];    }    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);}</code></pre><p>这样，sum数据的确更新成功，lazy数据也传导到子节点了，但是，我们发现，递归调用的中间路径上，遇到的内部节点的lazy[id]并没用做任何操作，而且，就我们设置lazy的方法来说，我们设置节点的子节点并没有设置lazy数据，换句话说，我们计算sum时，极有可能某个节点明明其父亲节点已经设置过了lazy了，但是由于我们并没有让lazy数据propagate down，在这个子节点上的sum数据获取是错误的。</p><p>再回到我们第二版的sum函数，我们是自顶向下进行split的，这意味着，我们可以将lazy数据自上向下传播开来。</p><pre><code>// 我们需要一个只传播lazy数据，但是不重设lazy数据的函数void shiftnoreset(int id, int l, int r){    int mid = (l + r)/2;    upd(id*2,l ,mid, lazy[id]);    upd(id*2+1,mid, r, lazy[id]);    //lazy[id] = 0;}// 第三版，在sum时，我们自顶向下的将lazy数据传播开来int sum(int x,int y ,int id = 1,int l =0 ,int r = n){    if(x &gt;= r ||  l &gt;= y) return 0;    if( x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-l));//只在这里清除了lazy        shift(id,l,r);        return s[id];    }    shiftnoreset(id,l,r);    int mid = (l + r)/2;    return sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);}</code></pre><p>第三版，虽然我们将lazy数据传播开来了，但是，我们只在最终节点处清楚了lazy数据，对于路径上的其它内部节点，下次再次访问的时候，必然会出现lazy的重复计算的问题。</p><pre><code>// 第四版，我们将lazy数据传播开来后，计算sum值，更新sum[id],那么此时的lazy[id]就不再有用了，可以方心清零了。int sum(int x, int y, int id=1, int l =0, int r = n){    if(x &gt;= r|| l &gt;= y) return 0;    if(x &lt;= l &amp;&amp; r &lt;= y)    {        s[id] += (lazy[id] * (r-1));        shift(id,l,r);        return s[id];    }    shift(id,l,r);// 我们传播开来lazy后就直接清零了    int mid = (l + r)/2;    s[id] =  sum(x,y,id*2, l,mid) + sum(x,y,id*2 +1,mid,r);    return s[id];}</code></pre><p>现在我们来研究下原版的代码：</p><pre><code>void upd(int id, int l, int r, int x){    lazy[id] += x;    s[id] += (r - l) *x;}   void shift(int id,int l, int r){    int mid = (l + r)/2;    upd(id *2 , l ,mid,lazy[id]);    upd(id*2+1,id, r, lazy[id]);    lazy[id] = 0;}void increase(int x,int y,int v, int id=1,int l =0, int r =n){    if(x &gt;= r|| l &gt;= y) return;    if(x&lt;= l || r &lt;= y)     {        upd(id, l,r, v);        return ;    }    shift(id ,l ,r);    int mid = (l + r)/2;    increase(x, y, v, id*2 l ,mid);    increase(x, y ,v, id*2 +1, mid,r);    s[id] = s[id*2] + s[id*2+1];}int sum(int x,int y, int id = 1, int l = 0,  int r = n){    if(x &gt;= r || l &gt;= y) return 0;    if(x&lt;= l &amp;&amp; r &lt;=y ) return s[id];    shift(id,l,r);    int mid = (l+r)/2;    return sum(x, y, id*2, l ,mid) + sum(x, y,id*2 +1, mid,r);}</code></pre><p>这里使用下图的结构，选择更新[0,8)这个区间+1,来研究下,不妨设原来的所有数据都是0。<a href=\"/assets/segmenttree/basic.png\">!operation 2</a></p><ul>  <li>从根节点[0,16)入手，更新lazy[1]到节点2与节点3。此时lazy[1] =0,所以没有任何变化；</li>  <li>进入左侧子节点[0,8),我们此时进入终止逻辑，更新节点2的lazy数据，lazy[2] = 1,更新sum值，s[2] += (8 - 0) * 1 ;</li>  <li>右侧的不做任何更新，循环停止。</li></ul><p>我们可以看到，此时，除了终止节点，所有路径上的内部节点均更新过了sum值，且lazy数据均为0。对于终止节点和终止节点之下的节点数据，在没有访问到时，我们可以放心的不管它，而在访问到时，我们进入sum函数逻辑。</p><p>假设我们需要求sum(2,3)的值。</p><ul>  <li>我们从节点2开始lazy数据一路向下传播，更新节点4与5，5不向下传播了；</li>  <li>节点4继续，更新节点8与节点9，8不继续向下传播了；</li>  <li>节点9注意到，直接返回s[id]了。这几个节点的sum数据在lazy传播过来的同时就更新了，所以这个数据时正确的。</li></ul><p>于是，我们得到正确的答案。</p>",
            "url": "http://localhost:4000/2020/01/16/segmenttree",
            
            
            
            
            
            "date_published": "2020-01-16T00:00:00+08:00",
            "date_modified": "2020-01-16T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/12/rtt-particle",
            "title": "Particle System rendered on Unity RT Image",
            "summary": null,
            "content_text": "本文目的: 对于项目中遇到的的在RT上显示特效的问题进行总结。综述项目最近需要在组队页面添加个星盘系统，所谓星盘，就是一大堆特效悬浮在人的周围。由于组队页面一直采用的是RT的方法进行显示，使用特效后，会出现局部黑片，效果非常差。这里探索下对应的处理方案。由于本篇文章总结的性质，这里把问题单独提出来研究。特效效果。问题特效的结构可以看到，对应的粒子的底图是黑色的。现在先禁用其它的特效，只留下单独的lizi_1001，我们可以看到单独的一个粒子的效果，当然这个效果是不正确的，我们需要对此 做出一些探究。Shader我们先来看下这个粒子效果的材质。这个粒子效果是由两个材质构成的，其中glow_2009对应着粒子图片的显示，而huahen_0001_a_01则对应着拖尾效果。我们主要看下在粒子图片的显示上。glow_2009使用了AddParticles的Shander：// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'Shader \"Artist/Effect/Add Particles\" {Properties {\t_Brightness (\"Brightness\", Float) = 1.0\t_TintColor (\"Tint Color\", Color) = (0.5,0.5,0.5,0.5)\t_MainTex (\"Particle Texture\", 2D) = \"white\" {}\t//_InvFade (\"Soft Particles Factor\", Range(0.01,3.0)) = 1.0}Category {\tTags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" }\t\tBlend SrcAlpha One\tAlphaTest Greater .01\tColorMask RGBA\tCull Off Lighting Off ZWrite Off Fog { Color (0,0,0,0) }\tBindChannels {\t\tBind \"Color\", color\t\tBind \"Vertex\", vertex\t\tBind \"TexCoord\", texcoord\t}\t\t// ---- Fragment program cards\tSubShader {\t\tLOD 150\t\tPass {\t\t\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t//#pragma fragmentoption ARB_precision_hint_fastest\t\t\t//#pragma multi_compile_particles\t\t\t#include \"UnityCG.cginc\"\t\t\tsampler2D _MainTex;\t\t\tfixed4 _TintColor;\t\t\tfloat _Brightness;\t\t\t\t\t\tstruct appdata_t {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfixed4 color : COLOR;\t\t\t\tfloat2 texcoord : TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfixed4 color : COLOR;\t\t\t\tfloat2 texcoord : TEXCOORD0;\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\tfloat4 projPos : TEXCOORD1;\t\t\t\t#endif*/\t\t\t};\t\t\t\t\t\tfloat4 _MainTex_ST;\t\t\tv2f vert (appdata_t v)\t\t\t{\t\t\t\tv2f o;\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\to.projPos = ComputeScreenPos (o.vertex);\t\t\t\tCOMPUTE_EYEDEPTH(o.projPos.z);\t\t\t\t#endif*/\t\t\t\to.color = v.color;\t\t\t\to.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex);\t\t\t\treturn o;\t\t\t}\t\t\t//sampler2D _CameraDepthTexture;\t\t\t//float _InvFade;\t\t\t\t\t\tfixed4 frag (v2f i) : COLOR\t\t\t{\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\tfloat sceneZ = LinearEyeDepth (UNITY_SAMPLE_DEPTH(tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos))));\t\t\t\tfloat partZ = i.projPos.z;\t\t\t\tfloat fade = saturate (_InvFade * (sceneZ-partZ));\t\t\t\ti.color.a *= fade;\t\t\t\t#endif*/\t\t\t\t\t\t\t\ti.color.rgb *= _Brightness;\t\t\t\treturn 2.0f * i.color * _TintColor * tex2D(_MainTex, i.texcoord);\t\t\t}\t\t\tENDCG \t\t}\t} \t\t\t// ---- Dual texture cards\t/*SubShader {\t\tPass {\t\t\tSetTexture [_MainTex] {\t\t\t\tconstantColor [_TintColor]\t\t\t\tcombine constant * primary\t\t\t}\t\t\tSetTexture [_MainTex] {\t\t\t\tcombine texture * previous DOUBLE\t\t\t}\t\t}\t}\t\t// ---- Single texture cards (does not do color tint)\tSubShader {\t\tPass {\t\t\tSetTexture [_MainTex] {\t\t\t\tcombine texture * primary\t\t\t}\t\t}\t}*/}}Shader比较简单，这里做个简要的说明：      这个Shader使用来显示Transparent的物体的，并采用的混合模式Blend SrcAlpha One，这个混合模式正好是Add Particles，即在原有的颜色的基础上加上当前的颜色。        ColorMask RGBA，这表示当前的Shader输出颜色和透明度。        BindChannels这个是Legacy的语法了，这里不起作用。        这个Shader只有一个通道，顶点对应着vert，着色对应着frag。        顶点函数基本上只是转了下位置坐标空间，UnityObjectToClipPos，并且拿了下uv的位置o.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex)。                  TRANSFORM_TEX这个函数单独说下，这是Unity定义的一个宏，定义为        // Transforms 2D UV by scale/bias property#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)                  fragment函数这里也只是做了个简单的颜色计算，附上了_Brightness这个属性。  从Shader这里我们可以看到，这个粒子效果是输出了Alpha值的，但是我们截下RT的alpha看下：可以看到，对应的位置的Alpha为全白的，即这里我们输出的Alpha值为1。那么自然，用这张图的UI图片在这个位置输出的是黑块了。实验 关闭Alpha通道的输出当我们关闭Alpha通道的输出时，ColorMask RGB，此时粒子效果干脆都不显示了。这里应该是因为，Alpha通道没有输出，默认直接设置为0了，经过RT这里直接就是不显示了。问题定位现在问题就比较好理解了。黑块对应的位置的Alpha值为1。但从Shader来看，我们是输出了Alpha值的，那只有可能是图片问题了。我们定位到图片：可以看到，这张图片是带Alpha通道的，我们看下Alpha通道的值：那么这个问题是美术的资源制作问题了，通知美术改下就好了。",
            "content_html": "<p>本文目的: 对于项目中遇到的的在RT上显示特效的问题进行总结。</p><!--more--><h2 id=\"综述\">综述</h2><p>项目最近需要在组队页面添加个星盘系统，所谓星盘，就是一大堆特效悬浮在人的周围。由于组队页面一直采用的是RT的方法进行显示，使用特效后，会出现局部黑片，效果非常差。这里探索下对应的处理方案。</p><p>由于本篇文章总结的性质，这里把问题单独提出来研究。</p><p>特效效果<img src=\"/assets/unity_rtt/2020_01_12_20_03.14.bmp\" alt=\"operation 1\" />。</p><p>问题特效的结构<img src=\"/assets/unity_rtt/2020_01_12_20_20.35.bmp\" alt=\"operation 2\" /></p><p>可以看到，对应的粒子的底图是黑色的。</p><p>现在先禁用其它的特效，只留下单独的<em>lizi_1001</em>，我们可以看到单独的一个粒子的效果<img src=\"/assets/unity_rtt/2020_01_12_20_34.42.bmp\" alt=\"operation 3\" />，当然这个效果是不正确的，我们需要对此 做出一些探究。</p><h2 id=\"shader\">Shader</h2><p>我们先来看下这个粒子效果的材质<img src=\"/assets/unity_rtt/2020_01_12_20_37.27.bmp\" alt=\"operation 4\" />。</p><p>这个粒子效果是由两个材质构成的，其中<em>glow_2009</em>对应着粒子图片的显示，而<em>huahen_0001_a_01</em>则对应着拖尾效果。我们主要看下在粒子图片的显示上。</p><p><em>glow_2009</em>使用了AddParticles的Shander：</p><pre><code class=\"language-glsl\">// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'Shader \"Artist/Effect/Add Particles\" {Properties {\t_Brightness (\"Brightness\", Float) = 1.0\t_TintColor (\"Tint Color\", Color) = (0.5,0.5,0.5,0.5)\t_MainTex (\"Particle Texture\", 2D) = \"white\" {}\t//_InvFade (\"Soft Particles Factor\", Range(0.01,3.0)) = 1.0}Category {\tTags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" }\t\tBlend SrcAlpha One\tAlphaTest Greater .01\tColorMask RGBA\tCull Off Lighting Off ZWrite Off Fog { Color (0,0,0,0) }\tBindChannels {\t\tBind \"Color\", color\t\tBind \"Vertex\", vertex\t\tBind \"TexCoord\", texcoord\t}\t\t// ---- Fragment program cards\tSubShader {\t\tLOD 150\t\tPass {\t\t\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t//#pragma fragmentoption ARB_precision_hint_fastest\t\t\t//#pragma multi_compile_particles\t\t\t#include \"UnityCG.cginc\"\t\t\tsampler2D _MainTex;\t\t\tfixed4 _TintColor;\t\t\tfloat _Brightness;\t\t\t\t\t\tstruct appdata_t {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfixed4 color : COLOR;\t\t\t\tfloat2 texcoord : TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfixed4 color : COLOR;\t\t\t\tfloat2 texcoord : TEXCOORD0;\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\tfloat4 projPos : TEXCOORD1;\t\t\t\t#endif*/\t\t\t};\t\t\t\t\t\tfloat4 _MainTex_ST;\t\t\tv2f vert (appdata_t v)\t\t\t{\t\t\t\tv2f o;\t\t\t\to.vertex = UnityObjectToClipPos(v.vertex);\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\to.projPos = ComputeScreenPos (o.vertex);\t\t\t\tCOMPUTE_EYEDEPTH(o.projPos.z);\t\t\t\t#endif*/\t\t\t\to.color = v.color;\t\t\t\to.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex);\t\t\t\treturn o;\t\t\t}\t\t\t//sampler2D _CameraDepthTexture;\t\t\t//float _InvFade;\t\t\t\t\t\tfixed4 frag (v2f i) : COLOR\t\t\t{\t\t\t\t/*#ifdef SOFTPARTICLES_ON\t\t\t\tfloat sceneZ = LinearEyeDepth (UNITY_SAMPLE_DEPTH(tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos))));\t\t\t\tfloat partZ = i.projPos.z;\t\t\t\tfloat fade = saturate (_InvFade * (sceneZ-partZ));\t\t\t\ti.color.a *= fade;\t\t\t\t#endif*/\t\t\t\t\t\t\t\ti.color.rgb *= _Brightness;\t\t\t\treturn 2.0f * i.color * _TintColor * tex2D(_MainTex, i.texcoord);\t\t\t}\t\t\tENDCG \t\t}\t} \t\t\t// ---- Dual texture cards\t/*SubShader {\t\tPass {\t\t\tSetTexture [_MainTex] {\t\t\t\tconstantColor [_TintColor]\t\t\t\tcombine constant * primary\t\t\t}\t\t\tSetTexture [_MainTex] {\t\t\t\tcombine texture * previous DOUBLE\t\t\t}\t\t}\t}\t\t// ---- Single texture cards (does not do color tint)\tSubShader {\t\tPass {\t\t\tSetTexture [_MainTex] {\t\t\t\tcombine texture * primary\t\t\t}\t\t}\t}*/}}</code></pre><p>Shader比较简单，这里做个简要的说明：</p><ul>  <li>    <p>这个Shader使用来显示<code>Transparent</code>的物体的，并采用的混合模式<code>Blend SrcAlpha One</code>，这个混合模式正好是<em>Add Particles</em>，即在原有的颜色的基础上加上当前的颜色。</p>  </li>  <li>    <p><code>ColorMask RGBA</code>，这表示当前的Shader输出颜色和透明度。</p>  </li>  <li>    <p><code>BindChannels</code>这个是Legacy的语法了，这里不起作用。</p>  </li>  <li>    <p>这个Shader只有一个通道，顶点对应着<code>vert</code>，着色对应着<code>frag</code>。</p>  </li>  <li>    <p>顶点函数基本上只是转了下位置坐标空间，<code>UnityObjectToClipPos</code>，并且拿了下uv的位置<code>o.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex)</code>。</p>    <ul>      <li>        <p><code>TRANSFORM_TEX</code>这个函数单独说下，这是Unity定义的一个宏，定义为</p>        <pre><code class=\"language-glsl\">// Transforms 2D UV by scale/bias property#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</code></pre>      </li>    </ul>  </li>  <li>    <p>fragment函数这里也只是做了个简单的颜色计算，附上了_Brightness这个属性。</p>  </li></ul><p>从Shader这里我们可以看到，这个粒子效果是输出了Alpha值的，但是我们截下RT的alpha看下：</p><p><img src=\"/assets/unity_rtt/2020_01_12_21_11.28.bmp\" alt=\"operation 5\" /></p><p>可以看到，</p><p>对应的位置的Alpha为全白的，即这里我们输出的Alpha值为1。那么自然，用这张图的UI图片在这个位置输出的是黑块了。</p><h2 id=\"实验-关闭alpha通道的输出\">实验 关闭Alpha通道的输出</h2><p>当我们关闭Alpha通道的输出时，<code>ColorMask RGB</code>，此时粒子效果干脆都不显示了。</p><p><img src=\"/assets/unity_rtt/2020_01_12_21_24.07.bmp\" alt=\"operation 6\" /></p><p>这里应该是因为，Alpha通道没有输出，默认直接设置为0了，经过RT这里直接就是不显示了。</p><h2 id=\"问题定位\">问题定位</h2><p>现在问题就比较好理解了。黑块对应的位置的Alpha值为1。但从Shader来看，我们是输出了Alpha值的，那只有可能是图片问题了。</p><p>我们定位到图片：</p><p><img src=\"/assets/unity_rtt/2020_01_12_21_28.12.bmp\" alt=\"operation 7\" /></p><p>可以看到，这张图片是带Alpha通道的，我们看下Alpha通道的值：</p><p><img src=\"/assets/unity_rtt/2020_01_12_21_30.55.bmp\" alt=\"operation 8\" /></p><p>那么这个问题是美术的资源制作问题了，通知美术改下就好了。</p>",
            "url": "http://localhost:4000/2020/01/12/rtt-particle",
            
            
            
            
            
            "date_published": "2020-01-12T00:00:00+08:00",
            "date_modified": "2020-01-12T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/05/intervaltree",
            "title": "interval trees",
            "summary": null,
            "content_text": "本文目的： 研究interval trees来加深对红黑树的理解。Augment Tree通过对已有的数据结构附加额外的属性，达到实现额外功能的目的。附加的额外属性要保证原数据结构的增删改查的时间复杂度不会有渐进意义上的增加。Interval Trees通过对红黑树附加额外的数据，我们要来实现对不同intervals 的组织。我们将每个interval看作一个节点x,节点x中含有额外的数据，x.int.low和x.int.high表示这个interval的区间，所有节点按照x.int.low作为key来组织。同时含有属性x.max,表示以x为根节点的子树上所有节点的high的最大值,即x.max = max(x.int.high,x.left.max,x.right.max)。我们先证明对于这棵树的delete和insert操作时间仍然时O(lgn)的。Proof:  向interval tree中插入一个节点分为两步：1. 将节点x插入到合适的位置；2. 如果插入的节点不满足红黑树的属性，我们需要做fixup。由于插入节点x及其所有祖先节点的max均有可能发生改变，我们需要更新O(lgn)个节点的属性值;对于需要旋转的节点，我们至多只需要做两次旋转，每次旋转只会动两个节点。我们最终只需要动O(lgn)个节点的属性。  向interval tree中删除一个节点同样可以分为两步：1.删除指定节点，将后继节点移动到被删除的节点的位置；2. 后继节点可能发生不满足红黑树属性的情况，需要做fixup.我们知道删除操作最多只会发生3次旋转，于是我们更新属性的时间最多仍然是O(lgn).查询INTERVAL-SEARCH(T,i)    x = T.root    while x != T.nil and i does not overlap x.int        if x.left != T.nil and x.left.max &gt;= i.low            x = x.left        else x = x.right    return xProof:考察循环的不变性：如果T有和interval i相交的interval，那么这个interval必然位于以x为根节点的子树上。Initialization:初始化时，x作为根节点，一定可以保证假设的正确。Maintenance:  如果当前节点x与i相交，循环终止。  如果循环进入x的右子树，说明此时x的左子树为空或者左子树的max &lt; i.low. 这两种情况均保证左子树不含与i相交的interval。  如果循环进入x的左子树，此时，必然有x.left.max &gt;= i.low。此时可以分为两种情况:          如果左子树中不含和i相交的interval。那么此时必然有,对任何左子树中满足i’.high &gt;= i.low的节点必然i.high &lt; i’.low。又由于我们树是按照interval.low进行组织的，这意味着i.high &lt; 所有右侧子树节点的int.low.      如果左子树中含和i相交的interval。此时假设满足，进入左子树继续处理。      Termination:如果循环终止于T.nil,由以上推导，可知，T中不含和i相交的节点。或者循环终止与找到某个节点x与i相交。代码实现这里借用了红黑树的结构，同时对红黑树做了一些重构。#ifndef __RED_BLACK_TREE_H__#define __RED_BLACK_TREE_H__ 1#include &lt;iostream&gt;#include &lt;queue&gt;const int RED = 0;const int BLACK = 1;const int BLACK_BLACK= 3;const int BLACK_RED = 4;template&lt;class T&gt;class BinNode{    public:        BinNode (const T&amp; data)            :_data(data)        {            _color = BLACK;            _lc = NULL;            _rc = NULL;            _p = NULL;        }        virtual ~BinNode (){}        int &amp; color() {return _color;}        BinNode*&amp; lc(){return _lc;}        BinNode*&amp; rc(){return _rc;}        BinNode*&amp; p(){return _p;}        T&amp; data(){return _data;}    private:    private:        /* data */        int _color;        BinNode* _lc;        BinNode* _rc;        BinNode* _p;        T _data;};template&lt;class T,class Node&gt;class BinTree{    public:class BinNode{    public:        BinNode (const Node&amp; data)            :_data(data)        {            _color = BLACK;            _lc = NULL;            _rc = NULL;            _p = NULL;        }        virtual ~BinNode (){}        int &amp; color() {return _color;}        Node*&amp; lc(){return _lc;}        Node*&amp; rc(){return _rc;}        Node*&amp; p(){return _p;}        T&amp; data(){return _data;}    private:    private:        /* data */        int _color;        BinNode* _lc;        BinNode* _rc;        BinNode* _p;        T _data;};    public:        static Node* nil;    public:        BinTree()        {            _root = nil;        }        void insert(Node* node);        Node* search(const T &amp; t) const;        void deletenode(Node* z);        void dfs();        void bfs();        Node* root(){return _root;}        void LeftRotate(Node* x) {left_rotate(x);}        void RightRotate(Node* x){right_rotate(x);}    protected:        virtual void left_rotate(Node* x);        virtual void right_rotate(Node* x);    private:        Node* search_recur(Node* node, const T&amp; t) const;        void insert_fixup(Node* node);        void transplant(Node* u, Node* v);        Node* minimum(Node* node);        void delete_fixup(Node* x);        void dfs_recur(Node* node);    protected:        Node* _root;    public:        static Node* make_node(const T&amp; t)        {            Node* node = new Node(t);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;        }};template&lt;class T&gt;class RedBlackTree:public BinTree&lt;T,BinNode&lt;T&gt;&gt;{};template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::nil = new Node(-1);template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::search(const T&amp; t) const{    return search_recur(_root, t);}template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::search_recur(Node* node, const T&amp; t) const{    if(node == nil) return nil;    if(node-&gt;data() == t) return node;    if(node-&gt;data() &lt; t)    {        return search_recur(node-&gt;rc(),t);    }    if (node-&gt;data() &gt; t)    {        return search_recur(node-&gt;lc(),t);    }    return nil;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::dfs(){    dfs_recur(_root);}static const char* getColor(int color){    if (color == RED)    {        return \"red\";    }    else if(color == BLACK)    {        return \"black\";    }    else if(color == BLACK_BLACK)    {        return \"black_black\";    }    else if(color == BLACK_RED)    {        return \"black_red\";    }    return \"\";}    template &lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::bfs(){    if (_root == nil) return;    std::queue&lt;Node* &gt; q;    q.push(_root);    int cur = 1;    int next =0;    while(q.size() &gt; 0)    {        Node* node = q.front();        q.pop();        std::cout&lt;&lt;node-&gt;data() &lt;&lt; \" \"&lt;&lt;getColor(node-&gt;color())&lt;&lt;\"    \";        if(node-&gt;lc() != NULL)        {            q.push(node-&gt;lc());            next ++;        }        if(node-&gt;rc() != NULL)        {            q.push(node-&gt;rc());            next += 1;        }        cur--;        if(cur &lt;=0)        {            std::cout&lt;&lt;std::endl;            cur = next;            next = 0;        }    }    std::cout&lt;&lt;std::endl;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::dfs_recur(Node* node){    if(node-&gt;lc() != nil)    {        dfs_recur(node-&gt;lc());    }    if(node-&gt;rc() != nil)    {        dfs_recur(node-&gt;rc());    }    std::cout&lt;&lt;\" \"&lt;&lt;node-&gt;data()&lt;&lt;\" \";}    template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::minimum(Node* node){    while(node-&gt;lc() != nil)    {        node = node-&gt;lc();    }    return node;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::transplant(Node* u, Node* v){    if(u-&gt;p() == nil)    {        _root = v;    }    else if(u == u-&gt;p()-&gt;lc())    {        u-&gt;p()-&gt;lc() = v;    }    else    {        u-&gt;p()-&gt;rc() = v;    }    v-&gt;p() = u-&gt;p();}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::deletenode(Node* z){    Node* y = z;    Node* x= nil;    int y_original_color = y-&gt;color();    if (z-&gt;lc() == nil)    {        x = z-&gt;rc();        transplant(z,z-&gt;rc());    }    else if(z-&gt;rc() == nil)    {        x = z-&gt;lc();        transplant(z,z-&gt;lc());    }    else    {        y = minimum(z-&gt;rc());        y_original_color = y-&gt;color();        x = y-&gt;rc();        if(y-&gt;p() == z)        {            x-&gt;p() = y;        }        else        {            transplant(y,y-&gt;rc());            y-&gt;rc() = z-&gt;rc();            y-&gt;rc()-&gt;p() = y;        }        transplant(z,y);        y-&gt;lc() = z-&gt;lc();        y-&gt;lc()-&gt;p() = y;        y-&gt;color() = z-&gt;color();    }    if(y_original_color == BLACK)    {        std::cout&lt;&lt;\"delete_fixup \"&lt;&lt;x-&gt;data()&lt;&lt;std::endl;        delete_fixup(x);    }}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::delete_fixup(Node* x){    Node * w;    while( x != _root &amp;&amp; x-&gt;color() == BLACK)    {        if(x == x-&gt;p()-&gt;lc())        {            w = x-&gt;p()-&gt;rc();            if(w-&gt;color() == RED) // case 1            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                w = x-&gt;p()-&gt;rc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;rc()-&gt;color() == BLACK)                {                    w-&gt;lc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    right_rotate(w);                    w = x-&gt;p()-&gt;rc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color()  = BLACK;                w-&gt;rc()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                x = _root;            }        }        else        {            w = x-&gt;p()-&gt;lc();            if(w-&gt;color() == RED)            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = RED;                right_rotate(x-&gt;p());                w = x-&gt;p()-&gt;lc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;lc()-&gt;color() == BLACK)                {                    w-&gt;rc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    left_rotate(w);                    w = x-&gt;p()-&gt;lc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color() = BLACK;                w-&gt;lc()-&gt;color() = BLACK;                right_rotate(x-&gt;p());                x = _root;            }        }    }    x-&gt;color() =BLACK;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::left_rotate(Node* x){    Node* y = x-&gt;rc();    x-&gt;rc() = y-&gt;lc();    if(y-&gt;lc() != nil)    {        y-&gt;lc()-&gt;p() = x;    }    y-&gt;p() = x-&gt;p();    if(x-&gt;p() == nil)    {        _root = y;    }    else if (x == x-&gt;p()-&gt;lc())    {        x-&gt;p()-&gt;lc() = y;    }    else if(x == x-&gt;p()-&gt;rc())    {        x-&gt;p()-&gt;rc() = y;    }    y-&gt;lc() = x;    x-&gt;p() = y;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::right_rotate(Node* y){    Node* x = y-&gt;lc();    y-&gt;lc()  = x-&gt;rc();    if(x-&gt;rc() != nil)    {        x-&gt;rc()-&gt;p() = y;    }    x-&gt;p() = y-&gt;p();    if(y-&gt;p() == nil)    {        _root = x;    }    else if(y == y-&gt;p()-&gt;lc())    {        y-&gt;p()-&gt;lc() = x;    }    else if(y == y-&gt;p()-&gt;rc())    {        y-&gt;p()-&gt;rc() =x;    }    x -&gt;rc() = y;    y-&gt;p() = x;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::insert_fixup(Node* z){    Node* y;    while(z-&gt;p()-&gt;color() == RED)    {        if(z-&gt;p() == z-&gt;p()-&gt;p()-&gt;lc())        {            y = z-&gt;p()-&gt;p()-&gt;rc();            if (y-&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if(z == z-&gt;p()-&gt;rc())                {                    z = z-&gt;p();                    left_rotate(z);                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                right_rotate(z-&gt;p()-&gt;p());            }        }        else        {            //std::cout&lt;&lt;\"case 2'\"&lt;&lt;std::endl;            y = z-&gt;p()-&gt;p()-&gt;lc();            if (y -&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if (z == z-&gt;p()-&gt;lc())                {                    z = z-&gt;p();                    right_rotate(z);                    //std::cout&lt;&lt;\"right_rotate for case 2\"&lt;&lt;std::endl;                    //bfs();                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                left_rotate(z-&gt;p()-&gt;p());            }        }    }    _root-&gt;color() = BLACK;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::insert(Node* node){    Node* y = nil;    Node* x= _root;;    while (x != nil)    {        y = x;        if(node-&gt;data() &lt; x-&gt;data())        {            x = x-&gt;lc();        }        else        {            x = x-&gt;rc();        }    }    node-&gt;p() = y;    if (y == nil )    {        _root = node;    }    else if(node-&gt;data() &lt; y-&gt;data())    {        y-&gt;lc() = node;    }    else    {        y-&gt;rc() = node;    }    node-&gt;lc() = nil;    node-&gt;rc() = nil;    node-&gt;color() = RED;    //std::cout&lt;&lt;\"before insert_fixup \"&lt;&lt;std::endl;    //bfs();    //std::cout&lt;&lt;\"===================\"&lt;&lt;std::endl;    insert_fixup(node);}#endif#ifndef __INTERVAL_TREE_H__#define __INTERVAL_TREE_H__ 1#include &lt;algorithm&gt;#include \"redblacktree.h\"// use low as BinNode keyclass IntervalNode{    public:        IntervalNode(int noop)            :_low(noop),_high(noop),_max(noop),_lc(NULL),_rc(NULL),_p(NULL)        {        }        IntervalNode(int low, int high)            :_low(low),_high(high),_max(high),_lc(NULL),_rc(NULL),_p(NULL)        {        }        IntervalNode*&amp; lc() {return _lc;}        IntervalNode*&amp; rc() {return _rc;}        IntervalNode*&amp; p() {return _p;}        int &amp; color() {return _color;}        int&amp; data() {return _low;}        int&amp; low() {return _low;}        int&amp; high() {return _high;}        int&amp; max() {return _max;}        bool overlap(IntervalNode* i)        {            return  _low &lt;= i-&gt;high() &amp;&amp; _high &gt;= i-&gt;low();        }    private:        int _low;        int _high;        int _max;        int _color;        IntervalNode* _lc;        IntervalNode* _rc;        IntervalNode* _p;};class IntervalTree:public BinTree&lt;int,IntervalNode&gt;{    public:        IntervalTree()        {        }    public:        static IntervalNode* make_node(int low, int high)        {            IntervalNode* node = new IntervalNode(low,high);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;         }    public:        IntervalNode* IntervalSearch(IntervalNode* i)        {           IntervalNode* x =this-&gt; _root;            while( x != nil &amp;&amp; ! x-&gt;overlap(i))           {               if(x-&gt;lc() != nil &amp;&amp; x-&gt;lc()-&gt;max() &gt; i-&gt;low())               {                    x= x-&gt;lc();               }               else               {                   x = x-&gt;rc();               }                                  }           return x;        }    protected:        void left_rotate(IntervalNode* x) override        {            IntervalNode* y = x-&gt;rc();            IntervalNode* y_lc = y-&gt;lc();            IntervalNode* y_rc = x-&gt;rc();            BinTree&lt;int,IntervalNode&gt;::left_rotate(x);            int x_max = x-&gt;high();            if( x-&gt;lc() != nil)            {                x_max = std::max(x_max, x-&gt;lc()-&gt;max());            }            if ( y_lc != nil)            {                x_max = std::max(x_max, y_lc-&gt;max());            }            x-&gt;max() = x_max;            int y_max = y-&gt;high();            y_max = std::max(y_max,x_max);            if(y_rc != nil)            {                y_max = std::max(y_max,y_rc-&gt;max());            }            y_rc-&gt;max() = y_max;        }        void right_rotate(IntervalNode* y)  override        {            IntervalNode* x = y-&gt;lc();            IntervalNode* x_lc = x-&gt;lc();            IntervalNode* x_rc = x-&gt;rc();            BinTree&lt;int,IntervalNode&gt;::right_rotate(y);            int y_max = y-&gt;high();            if (x_rc != nil)            {                y_max = std::max(x_rc-&gt;max(),y_max);            }            if(y-&gt;rc() != nil)            {                y_max = std::max(y-&gt;rc()-&gt;max(),y_max);            }            y-&gt;max() = y_max;            int x_max = x-&gt;high();            x_max = std::max(x_max, y_max);            if(x_lc != nil)            {                x_max = std::max(x_lc-&gt;max(), x_max);            }            x-&gt;max() = x_max;        }};#endif ",
            "content_html": "<p>本文目的： 研究interval trees来加深对红黑树的理解。</p><!--more--><h3 id=\"augment-tree\">Augment Tree</h3><p>通过对已有的数据结构附加额外的属性，达到实现额外功能的目的。附加的额外属性要保证原数据结构的增删改查的时间复杂度不会有渐进意义上的增加。</p><h2 id=\"interval-trees\">Interval Trees</h2><p>通过对红黑树附加额外的数据，我们要来实现对不同intervals 的组织。</p><p>我们将每个interval看作一个节点x,节点x中含有额外的数据，x.int.low和x.int.high表示这个interval的区间，所有节点按照x.int.low作为key来组织。同时含有属性x.max,表示以x为根节点的子树上所有节点的high的最大值,即<code>x.max = max(x.int.high,x.left.max,x.right.max)</code>。</p><p>我们先证明对于这棵树的delete和insert操作时间仍然时O(lgn)的。</p><p>Proof:</p><ul>  <li>向interval tree中插入一个节点分为两步：1. 将节点x插入到合适的位置；2. 如果插入的节点不满足红黑树的属性，我们需要做fixup。由于插入节点x及其所有祖先节点的max均有可能发生改变，我们需要更新O(lgn)个节点的属性值;对于需要旋转的节点，我们至多只需要做两次旋转，每次旋转只会动两个节点。我们最终只需要动O(lgn)个节点的属性。</li>  <li>向interval tree中删除一个节点同样可以分为两步：1.删除指定节点，将后继节点移动到被删除的节点的位置；2. 后继节点可能发生不满足红黑树属性的情况，需要做fixup.我们知道删除操作最多只会发生3次旋转，于是我们更新属性的时间最多仍然是O(lgn).</li></ul><h2 id=\"查询\">查询</h2><pre><code>INTERVAL-SEARCH(T,i)    x = T.root    while x != T.nil and i does not overlap x.int        if x.left != T.nil and x.left.max &gt;= i.low            x = x.left        else x = x.right    return x</code></pre><p>Proof:</p><p>考察循环的不变性：如果T有和interval i相交的interval，那么这个interval必然位于以x为根节点的子树上。</p><p>Initialization:</p><p>初始化时，x作为根节点，一定可以保证假设的正确。</p><p>Maintenance:</p><ul>  <li>如果当前节点x与i相交，循环终止。</li>  <li>如果循环进入x的右子树，说明此时x的左子树为空或者左子树的max &lt; i.low. 这两种情况均保证左子树不含与i相交的interval。</li>  <li>如果循环进入x的左子树，此时，必然有x.left.max &gt;= i.low。此时可以分为两种情况:    <ul>      <li>如果左子树中不含和i相交的interval。那么此时必然有,对任何左子树中满足i’.high &gt;= i.low的节点必然i.high &lt; i’.low。又由于我们树是按照interval.low进行组织的，这意味着i.high &lt; 所有右侧子树节点的int.low.</li>      <li>如果左子树中含和i相交的interval。此时假设满足，进入左子树继续处理。</li>    </ul>  </li></ul><p>Termination:</p><p>如果循环终止于T.nil,由以上推导，可知，T中不含和i相交的节点。或者循环终止与找到某个节点x与i相交。</p><h2 id=\"代码实现\">代码实现</h2><p>这里借用了红黑树的结构，同时对红黑树做了一些重构。</p><pre><code>#ifndef __RED_BLACK_TREE_H__#define __RED_BLACK_TREE_H__ 1#include &lt;iostream&gt;#include &lt;queue&gt;const int RED = 0;const int BLACK = 1;const int BLACK_BLACK= 3;const int BLACK_RED = 4;template&lt;class T&gt;class BinNode{    public:        BinNode (const T&amp; data)            :_data(data)        {            _color = BLACK;            _lc = NULL;            _rc = NULL;            _p = NULL;        }        virtual ~BinNode (){}        int &amp; color() {return _color;}        BinNode*&amp; lc(){return _lc;}        BinNode*&amp; rc(){return _rc;}        BinNode*&amp; p(){return _p;}        T&amp; data(){return _data;}    private:    private:        /* data */        int _color;        BinNode* _lc;        BinNode* _rc;        BinNode* _p;        T _data;};template&lt;class T,class Node&gt;class BinTree{    public:class BinNode{    public:        BinNode (const Node&amp; data)            :_data(data)        {            _color = BLACK;            _lc = NULL;            _rc = NULL;            _p = NULL;        }        virtual ~BinNode (){}        int &amp; color() {return _color;}        Node*&amp; lc(){return _lc;}        Node*&amp; rc(){return _rc;}        Node*&amp; p(){return _p;}        T&amp; data(){return _data;}    private:    private:        /* data */        int _color;        BinNode* _lc;        BinNode* _rc;        BinNode* _p;        T _data;};    public:        static Node* nil;    public:        BinTree()        {            _root = nil;        }        void insert(Node* node);        Node* search(const T &amp; t) const;        void deletenode(Node* z);        void dfs();        void bfs();        Node* root(){return _root;}        void LeftRotate(Node* x) {left_rotate(x);}        void RightRotate(Node* x){right_rotate(x);}    protected:        virtual void left_rotate(Node* x);        virtual void right_rotate(Node* x);    private:        Node* search_recur(Node* node, const T&amp; t) const;        void insert_fixup(Node* node);        void transplant(Node* u, Node* v);        Node* minimum(Node* node);        void delete_fixup(Node* x);        void dfs_recur(Node* node);    protected:        Node* _root;    public:        static Node* make_node(const T&amp; t)        {            Node* node = new Node(t);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;        }};template&lt;class T&gt;class RedBlackTree:public BinTree&lt;T,BinNode&lt;T&gt;&gt;{};template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::nil = new Node(-1);template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::search(const T&amp; t) const{    return search_recur(_root, t);}template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::search_recur(Node* node, const T&amp; t) const{    if(node == nil) return nil;    if(node-&gt;data() == t) return node;    if(node-&gt;data() &lt; t)    {        return search_recur(node-&gt;rc(),t);    }    if (node-&gt;data() &gt; t)    {        return search_recur(node-&gt;lc(),t);    }    return nil;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::dfs(){    dfs_recur(_root);}static const char* getColor(int color){    if (color == RED)    {        return \"red\";    }    else if(color == BLACK)    {        return \"black\";    }    else if(color == BLACK_BLACK)    {        return \"black_black\";    }    else if(color == BLACK_RED)    {        return \"black_red\";    }    return \"\";}    template &lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::bfs(){    if (_root == nil) return;    std::queue&lt;Node* &gt; q;    q.push(_root);    int cur = 1;    int next =0;    while(q.size() &gt; 0)    {        Node* node = q.front();        q.pop();        std::cout&lt;&lt;node-&gt;data() &lt;&lt; \" \"&lt;&lt;getColor(node-&gt;color())&lt;&lt;\"    \";        if(node-&gt;lc() != NULL)        {            q.push(node-&gt;lc());            next ++;        }        if(node-&gt;rc() != NULL)        {            q.push(node-&gt;rc());            next += 1;        }        cur--;        if(cur &lt;=0)        {            std::cout&lt;&lt;std::endl;            cur = next;            next = 0;        }    }    std::cout&lt;&lt;std::endl;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::dfs_recur(Node* node){    if(node-&gt;lc() != nil)    {        dfs_recur(node-&gt;lc());    }    if(node-&gt;rc() != nil)    {        dfs_recur(node-&gt;rc());    }    std::cout&lt;&lt;\" \"&lt;&lt;node-&gt;data()&lt;&lt;\" \";}    template&lt;class T,class Node&gt;Node* BinTree&lt;T,Node&gt;::minimum(Node* node){    while(node-&gt;lc() != nil)    {        node = node-&gt;lc();    }    return node;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::transplant(Node* u, Node* v){    if(u-&gt;p() == nil)    {        _root = v;    }    else if(u == u-&gt;p()-&gt;lc())    {        u-&gt;p()-&gt;lc() = v;    }    else    {        u-&gt;p()-&gt;rc() = v;    }    v-&gt;p() = u-&gt;p();}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::deletenode(Node* z){    Node* y = z;    Node* x= nil;    int y_original_color = y-&gt;color();    if (z-&gt;lc() == nil)    {        x = z-&gt;rc();        transplant(z,z-&gt;rc());    }    else if(z-&gt;rc() == nil)    {        x = z-&gt;lc();        transplant(z,z-&gt;lc());    }    else    {        y = minimum(z-&gt;rc());        y_original_color = y-&gt;color();        x = y-&gt;rc();        if(y-&gt;p() == z)        {            x-&gt;p() = y;        }        else        {            transplant(y,y-&gt;rc());            y-&gt;rc() = z-&gt;rc();            y-&gt;rc()-&gt;p() = y;        }        transplant(z,y);        y-&gt;lc() = z-&gt;lc();        y-&gt;lc()-&gt;p() = y;        y-&gt;color() = z-&gt;color();    }    if(y_original_color == BLACK)    {        std::cout&lt;&lt;\"delete_fixup \"&lt;&lt;x-&gt;data()&lt;&lt;std::endl;        delete_fixup(x);    }}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::delete_fixup(Node* x){    Node * w;    while( x != _root &amp;&amp; x-&gt;color() == BLACK)    {        if(x == x-&gt;p()-&gt;lc())        {            w = x-&gt;p()-&gt;rc();            if(w-&gt;color() == RED) // case 1            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                w = x-&gt;p()-&gt;rc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;rc()-&gt;color() == BLACK)                {                    w-&gt;lc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    right_rotate(w);                    w = x-&gt;p()-&gt;rc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color()  = BLACK;                w-&gt;rc()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                x = _root;            }        }        else        {            w = x-&gt;p()-&gt;lc();            if(w-&gt;color() == RED)            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = RED;                right_rotate(x-&gt;p());                w = x-&gt;p()-&gt;lc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;lc()-&gt;color() == BLACK)                {                    w-&gt;rc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    left_rotate(w);                    w = x-&gt;p()-&gt;lc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color() = BLACK;                w-&gt;lc()-&gt;color() = BLACK;                right_rotate(x-&gt;p());                x = _root;            }        }    }    x-&gt;color() =BLACK;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::left_rotate(Node* x){    Node* y = x-&gt;rc();    x-&gt;rc() = y-&gt;lc();    if(y-&gt;lc() != nil)    {        y-&gt;lc()-&gt;p() = x;    }    y-&gt;p() = x-&gt;p();    if(x-&gt;p() == nil)    {        _root = y;    }    else if (x == x-&gt;p()-&gt;lc())    {        x-&gt;p()-&gt;lc() = y;    }    else if(x == x-&gt;p()-&gt;rc())    {        x-&gt;p()-&gt;rc() = y;    }    y-&gt;lc() = x;    x-&gt;p() = y;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::right_rotate(Node* y){    Node* x = y-&gt;lc();    y-&gt;lc()  = x-&gt;rc();    if(x-&gt;rc() != nil)    {        x-&gt;rc()-&gt;p() = y;    }    x-&gt;p() = y-&gt;p();    if(y-&gt;p() == nil)    {        _root = x;    }    else if(y == y-&gt;p()-&gt;lc())    {        y-&gt;p()-&gt;lc() = x;    }    else if(y == y-&gt;p()-&gt;rc())    {        y-&gt;p()-&gt;rc() =x;    }    x -&gt;rc() = y;    y-&gt;p() = x;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::insert_fixup(Node* z){    Node* y;    while(z-&gt;p()-&gt;color() == RED)    {        if(z-&gt;p() == z-&gt;p()-&gt;p()-&gt;lc())        {            y = z-&gt;p()-&gt;p()-&gt;rc();            if (y-&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if(z == z-&gt;p()-&gt;rc())                {                    z = z-&gt;p();                    left_rotate(z);                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                right_rotate(z-&gt;p()-&gt;p());            }        }        else        {            //std::cout&lt;&lt;\"case 2'\"&lt;&lt;std::endl;            y = z-&gt;p()-&gt;p()-&gt;lc();            if (y -&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if (z == z-&gt;p()-&gt;lc())                {                    z = z-&gt;p();                    right_rotate(z);                    //std::cout&lt;&lt;\"right_rotate for case 2\"&lt;&lt;std::endl;                    //bfs();                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                left_rotate(z-&gt;p()-&gt;p());            }        }    }    _root-&gt;color() = BLACK;}    template&lt;class T,class Node&gt;void BinTree&lt;T,Node&gt;::insert(Node* node){    Node* y = nil;    Node* x= _root;;    while (x != nil)    {        y = x;        if(node-&gt;data() &lt; x-&gt;data())        {            x = x-&gt;lc();        }        else        {            x = x-&gt;rc();        }    }    node-&gt;p() = y;    if (y == nil )    {        _root = node;    }    else if(node-&gt;data() &lt; y-&gt;data())    {        y-&gt;lc() = node;    }    else    {        y-&gt;rc() = node;    }    node-&gt;lc() = nil;    node-&gt;rc() = nil;    node-&gt;color() = RED;    //std::cout&lt;&lt;\"before insert_fixup \"&lt;&lt;std::endl;    //bfs();    //std::cout&lt;&lt;\"===================\"&lt;&lt;std::endl;    insert_fixup(node);}#endif</code></pre><pre><code>#ifndef __INTERVAL_TREE_H__#define __INTERVAL_TREE_H__ 1#include &lt;algorithm&gt;#include \"redblacktree.h\"// use low as BinNode keyclass IntervalNode{    public:        IntervalNode(int noop)            :_low(noop),_high(noop),_max(noop),_lc(NULL),_rc(NULL),_p(NULL)        {        }        IntervalNode(int low, int high)            :_low(low),_high(high),_max(high),_lc(NULL),_rc(NULL),_p(NULL)        {        }        IntervalNode*&amp; lc() {return _lc;}        IntervalNode*&amp; rc() {return _rc;}        IntervalNode*&amp; p() {return _p;}        int &amp; color() {return _color;}        int&amp; data() {return _low;}        int&amp; low() {return _low;}        int&amp; high() {return _high;}        int&amp; max() {return _max;}        bool overlap(IntervalNode* i)        {            return  _low &lt;= i-&gt;high() &amp;&amp; _high &gt;= i-&gt;low();        }    private:        int _low;        int _high;        int _max;        int _color;        IntervalNode* _lc;        IntervalNode* _rc;        IntervalNode* _p;};class IntervalTree:public BinTree&lt;int,IntervalNode&gt;{    public:        IntervalTree()        {        }    public:        static IntervalNode* make_node(int low, int high)        {            IntervalNode* node = new IntervalNode(low,high);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;         }    public:        IntervalNode* IntervalSearch(IntervalNode* i)        {           IntervalNode* x =this-&gt; _root;            while( x != nil &amp;&amp; ! x-&gt;overlap(i))           {               if(x-&gt;lc() != nil &amp;&amp; x-&gt;lc()-&gt;max() &gt; i-&gt;low())               {                    x= x-&gt;lc();               }               else               {                   x = x-&gt;rc();               }                                  }           return x;        }    protected:        void left_rotate(IntervalNode* x) override        {            IntervalNode* y = x-&gt;rc();            IntervalNode* y_lc = y-&gt;lc();            IntervalNode* y_rc = x-&gt;rc();            BinTree&lt;int,IntervalNode&gt;::left_rotate(x);            int x_max = x-&gt;high();            if( x-&gt;lc() != nil)            {                x_max = std::max(x_max, x-&gt;lc()-&gt;max());            }            if ( y_lc != nil)            {                x_max = std::max(x_max, y_lc-&gt;max());            }            x-&gt;max() = x_max;            int y_max = y-&gt;high();            y_max = std::max(y_max,x_max);            if(y_rc != nil)            {                y_max = std::max(y_max,y_rc-&gt;max());            }            y_rc-&gt;max() = y_max;        }        void right_rotate(IntervalNode* y)  override        {            IntervalNode* x = y-&gt;lc();            IntervalNode* x_lc = x-&gt;lc();            IntervalNode* x_rc = x-&gt;rc();            BinTree&lt;int,IntervalNode&gt;::right_rotate(y);            int y_max = y-&gt;high();            if (x_rc != nil)            {                y_max = std::max(x_rc-&gt;max(),y_max);            }            if(y-&gt;rc() != nil)            {                y_max = std::max(y-&gt;rc()-&gt;max(),y_max);            }            y-&gt;max() = y_max;            int x_max = x-&gt;high();            x_max = std::max(x_max, y_max);            if(x_lc != nil)            {                x_max = std::max(x_lc-&gt;max(), x_max);            }            x-&gt;max() = x_max;        }};#endif </code></pre>",
            "url": "http://localhost:4000/2020/01/05/intervaltree",
            
            
            
            
            
            "date_published": "2020-01-05T00:00:00+08:00",
            "date_modified": "2020-01-05T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/04/faststringsearch",
            "title": "BM算法（字符串快速匹配算法）",
            "summary": null,
            "content_text": "本文目的在于研究BM算法的大概思路。BM算法字符串string匹配串P，长度patlen。对字符串T和匹配串P进行匹配，如果自右向左进行匹配，而不是自左向右，有如下观察：  如果对于第一个匹配，即P[patlen]处的字符X和T[i]处的字符Y不匹配，而匹配串P中不含任何Y，那么我们下次匹配的时候，可以直接跳过Y，那么下次匹配的时候可以直接右移patlen的长度即可。  如果P中包含Y,假设Y的字符的位置距离P右侧的距离为delta，那么此时，我们可以直接将P右移delta的长度，直接让P中右边第一个Y出现的位置对上我们当前string中正在匹配的字符Y。  现在假设我们自右边开始的匹配一一满足，那么我们可以一直自右向左的匹配。那么此时只有两种结果，或者我们全部匹配完了P，此时我们匹配成功了；或者我们在某个位置匹配失败。很明显，现在感兴趣的是我们在某个位置匹配失败的情况。我们把在某个失败之前匹配成功的距离记为m。3(a) 我们可以基于之前的逻辑，在X的左侧，我们找到第一个出现的Y，我们假设这个Y为Y1，将Y1右移动到我们string中目前Y的位置。假设这个Y1距离X的长度为k，那么我们只需右移k即可。此时，我们重新开始匹配的话，通用从P的最右端开始匹配，匹配的位置距离当前位置k+m的长度。假设，P中最右侧的Y1出现在X的右侧，此时，P可以使得Y1与Y进行匹配，但这并不是我们想要的。或者说，对于回退P的验证，我们应该在之前的搜寻中包括了。此时，我们简单的右移1.3(b)现在我们看下另一种情况。同样在第一次不匹配之前，我们已经匹配了m个字符了，我们把这个字符串称为子串sP，那么，我们可预想到，在下次右移后，这个子串sP一定是匹配的，或者说sP在P中，除了末尾出现一次，还在之前也出现过。且这个子串的前序字符Z一定与X不一致。目前为止，我们已经说了三种可以跳转的情况，我们只需从这三种情况中选择最远的跳转即可。算法input:\tstring, pat\t\tstringlen := length of string\t\ti := patlentop:\t\t\tif i&gt; stringlen then return false\t\tj := patlenloop:\t\t\tif j==0 then return i+1\t\tif string(i) == pat(j) then\t\t\tj = j - 1\t\t\ti = i - 1\t\t\tgoto loop\t\t\tclose;\t\ti = i + max(delta1(string(i)), delta2(j))\t\tgoto topdelta1(char) :=  if char does not occur in pat, \t\t\t\t\tthen patlen;\t\t\t\telse patlen - j,\t\t\t\twhere j is the maximum integer such that\t\t\t\tpat(j) == char.delta2(j)\t:= k + m\t\t\tk : the discovered occurence (in string) of the last patlen-j characters of pat\t\t\tm : additional distance we have already matched\t\t\t:= patlen + 1 - rpr(j)rpr(j)\t\t:= the rightmost plausible reoccurrence delta1的构造make_delta1:input:\tpat\t\t\t\tpatlen := pat.length\t\tdelta1 := array[256] // 把所有字符表都遍历一遍, array 从1开始\t\tj := 1;loop:\t\tdelta1[j] := patlen\t\tj := j + 1\t\tif j &lt;= 256 then goto loop\t\tj := 1;delta:\t\tdelta1[pat[j]] := patlen - j\t\tif j &lt;= patlen then goto delta\t\tdelta2的构造我们先构造rpr表，即对每一个后缀找到the rightmost plausible reoccurrence.这里论文中没有给出明确的方案，这里搜寻了下wiki采用wiki里提到的delta2的实现方案，并且只考虑rpr的情况。这里统一下标从1开始计算。suffix_length: // 算出在pos处最长后缀的长度input:\tpat, pos\t\tpatlen := pat.length\t\ti := 0\t\tloop:\tif (pat[pos-i] == word[patlen-i]) and ( i&lt; pos) then\t\t\t++i\t\t\tgoto loop\t\t\t\t\treturn imake_delta2:input:\tpat\t\tpatlen := pat.length\t\tp := 1\t\tloop:\t\t\tif p &lt; patlen then\t\t\tslen := suffix_length(pat, p)\t\t\tif ((p-slen &lt;=0) or // 这里加个前序不存在的判定,wiki里这种情况通过loop1考虑了\t\t\t\t(pat[p-slen] != pat[patlen - slen]) then\t\t\t\tdelta2[patlen - slen] = patlen - p + slen\t\t\tp ++\t\t\tgoto loop实现细节使用delta0替换delta1，delta0(pat(patlen)) := large := stringlen + patlen + 1input: \tstring, pat\t\tstringlen := string.length\t\tpatlen := pat.length\t\ti := patlen\t\tif i &gt; stringlen then return falsefast:\t\t\ti := i + delta0(string(i))\t\tif i&lt;= stringlen then goto fastundo:\tif i &lt;= large then \treturn false\t\ti := (i - large) -1\t\tj := patlen -1slow:\tif j == 0 return i + 1\t\tif string(i) == pat(j)\t\t\tthen \t\t\tj := j-1\t\t\ti := i-1\t\t\tgoto slow\t\t\tclose\t\ti := i + max(delta1(string(i)), delta2(j))\t\tgoto fast\t\t\t这部分代码比较难理解。是作者为了优化算法速度做的实现，原理与之前的版本是一致的。这里细细剖析下。首先看下fast循环进来和结束的状态与条件：  程序开始时进入，此时i &lt;= stringlen，或者确切的说i := patlen。进入fast后运行i := i + string(patlen)。          如果，string(patlen)与pat(patlen)不相等，此时右移到下一次匹配的位置；      如果，string(patlen)与pat(patlen)相等，此时右移large；      判断 i &lt;= stringlen，如果i &gt; stringlen，并且i &gt; large，这说明我们的末尾字符匹配成功，可以进入slow逻辑继续匹配。      如果i&gt; stringlen,但i &lt;= large，这说明，我们末尾字符没有匹配成功，但是i移出了string的范围，匹配失败。        从slow中进入，此时string(i) != pat(j)，出现了第一次不匹配，i更新为i + max(delta1(string(i)), delta2(j))，注意这里，使用的仍然是delta1。slow的逻辑与原版算法基本一致。这版算法将对patlen处字符的匹配单独提出，作者评估过80%的匹配时间都消耗在fastloop，通过将这部分代码单独提出，使用机器指令单独编码，可以加快算法的运行速度。理论分析这部分见论文吧，通过概率模型分析，运行时间是c*(i + patlen) c&lt; 1。代码实现#include &lt;iostream&gt;#include &lt;algorithm&gt;void make_delta1(const char* pat, int patlen, int* delta1){\t\tfor(int i = 0; i &lt; 256; ++i)\t{\t\tdelta1[i] = patlen;\t}\tfor(int i = 0; i &lt; patlen; ++i)\t{\t\tdelta1[(int)pat[i]] = patlen - i -1; // we start index from zero\t\t}}int suffix_length(const char* pat, int patlen,int pos){\tint i = 0;\twhile( i &lt;= pos \t\t\t&amp;&amp; pat[pos-i] == pat[patlen-i-1])\t{\t\t\t++i;\t\t\t\t}\treturn i;}void make_delta2(const char* pat, int patlen, int* delta2){\t\t// 默认正在p处不匹配时，直接移动到+1的位置进行新的匹配，\t// 最慢的\t// 默认值\tfor(int p = 0; p &lt; patlen; ++p)\t{\t\tdelta2[p] = patlen - p ;\t}\tfor(int p = 0; p &lt; patlen-1;++p)\t{\t\tint slen = suffix_length(pat, patlen, p);\t\t\t\tif(p - slen &lt; 0 || pat[p-slen] != pat[patlen-slen])\t\t{\t\t\tdelta2[patlen-slen -1] = patlen - p -1 + slen;\t\t\t//std::cout&lt;&lt;\" set delta2 \"&lt;&lt;patlen-slen -1 &lt;&lt; \" = \"&lt;&lt;patlen-p-1 + slen&lt;&lt;std::endl;\t\t}\t}}int match(const char* txt, int txtLen, const char* pat, int patlen){\t\t\t\tint delta1[256];\t\tmake_delta1(pat, patlen, delta1);\t\t\t\tint* delta2 = new int[patlen];\t\tmake_delta2(pat, patlen, delta2);\t\t\t\tint j = patlen-1;\t\tint i = patlen - 1;\t\twhile( i &lt; txtLen)\t\t{\t\t\tint j = patlen-1;\t\t\t//std::cout&lt;&lt;\" i = \"&lt;&lt;i&lt;&lt;\" j = \"&lt;&lt;j&lt;&lt;std::endl;\t\t\twhile( j &gt;= 0)\t\t\t{\t\t\t\t//std::cout&lt;&lt;\" compare \"&lt;&lt;txt[i] &lt;&lt; \" and \"&lt;&lt;pat[j]&lt;&lt;std::endl;\t\t\t\tif(txt[i] == pat[j])\t\t\t\t{\t\t\t\t\tj--;\t\t\t\t\ti--;\t\t\t\t}\t\t\t\telse{\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tif(j &lt;0)\t\t\t{\t\t\t\treturn i + 1;\t\t\t}\t\t\t//std::cout&lt;&lt;\" delta1 = \"&lt;&lt;delta1[txt[i]] &lt;&lt; \" delta2 = \"&lt;&lt;delta2[j]&lt;&lt;std::endl;\t\t\ti = i + std::max(delta1[txt[i]],delta2[j]);\t\t}\t\treturn -1;}附在 “Knuth D.E. Morris J.H., and Pratt, V.R. Fast pattern matching in strings”中Knuth提出了线性时间构造delta2的方法。参考论文“A Fast String Searching Algorithm”",
            "content_html": "<p>本文目的在于研究BM算法的大概思路。</p><h3 id=\"bm算法\">BM算法</h3><p>字符串string匹配串P，长度patlen。对字符串T和匹配串P进行匹配，如果自右向左进行匹配，而不是自左向右，有如下观察：</p><ol>  <li>如果对于第一个匹配，即P[patlen]处的字符X和T[i]处的字符Y不匹配，而匹配串P中不含任何Y，那么我们下次匹配的时候，可以直接跳过Y，那么下次匹配的时候可以直接右移patlen的长度即可。<img src=\"/assets/faststringsearch/2019_12_23_21_36.46.bmp\" alt=\"operation 1\" /></li>  <li>如果P中包含Y,假设Y的字符的位置距离P右侧的距离为delta，那么此时，我们可以直接将P右移delta的长度，直接让P中右边第一个Y出现的位置对上我们当前string中正在匹配的字符Y。<img src=\"/assets/faststringsearch/2019_12_23_22_07.51.bmp\" alt=\"operation 2\" /></li>  <li>现在假设我们自右边开始的匹配一一满足，那么我们可以一直自右向左的匹配。那么此时只有两种结果，或者我们全部匹配完了P，此时我们匹配成功了；或者我们在某个位置匹配失败。很明显，现在感兴趣的是我们在某个位置匹配失败的情况。我们把在某个失败之前匹配成功的距离记为m。<img src=\"/assets/faststringsearch/2019_12_23_22_23.17.bmp\" alt=\"operation 3\" />3(a) 我们可以基于之前的逻辑，在X的左侧，我们找到第一个出现的Y，我们假设这个Y为Y1，将Y1右移动到我们string中目前Y的位置。假设这个Y1距离X的长度为k，那么我们只需右移k即可。<img src=\"/assets/faststringsearch/2019_12_24_10_17.34.bmp\" alt=\"operation 4\" />此时，我们重新开始匹配的话，通用从P的最右端开始匹配，匹配的位置距离当前位置k+m的长度。假设，P中最右侧的Y1出现在X的右侧，此时，P可以使得Y1与Y进行匹配，但这并不是我们想要的。或者说，对于回退P的验证，我们应该在之前的搜寻中包括了。此时，我们简单的右移1.<img src=\"/assets/faststringsearch/2019_12_24_10_54.53.bmp\" alt=\"operation 5\" /><img src=\"/assets/faststringsearch/2019_12_24_10_57.36.bmp\" alt=\"operation 6\" />3(b)现在我们看下另一种情况。同样在第一次不匹配之前，我们已经匹配了m个字符了，我们把这个字符串称为子串sP，那么，我们可预想到，在下次右移后，这个子串sP一定是匹配的，或者说sP在P中，除了末尾出现一次，还在之前也出现过。且这个子串的前序字符Z一定与X不一致。<img src=\"/assets/faststringsearch/2019_12_24_11_23.38.bmp\" alt=\"operation 7\" /><img src=\"/assets/faststringsearch/2019_12_24_11_35.25.bmp\" alt=\"operation 8\" /></li></ol><p>目前为止，我们已经说了三种可以跳转的情况，我们只需从这三种情况中选择最远的跳转即可。</p><h2 id=\"算法\">算法</h2><pre><code>input:\tstring, pat\t\tstringlen := length of string\t\ti := patlentop:\t\t\tif i&gt; stringlen then return false\t\tj := patlenloop:\t\t\tif j==0 then return i+1\t\tif string(i) == pat(j) then\t\t\tj = j - 1\t\t\ti = i - 1\t\t\tgoto loop\t\t\tclose;\t\ti = i + max(delta1(string(i)), delta2(j))\t\tgoto top</code></pre><pre><code>delta1(char) :=  if char does not occur in pat, \t\t\t\t\tthen patlen;\t\t\t\telse patlen - j,\t\t\t\twhere j is the maximum integer such that\t\t\t\tpat(j) == char.delta2(j)\t:= k + m\t\t\tk : the discovered occurence (in string) of the last patlen-j characters of pat\t\t\tm : additional distance we have already matched\t\t\t:= patlen + 1 - rpr(j)rpr(j)\t\t:= the rightmost plausible reoccurrence </code></pre><h3 id=\"delta1的构造\">delta1的构造</h3><pre><code>make_delta1:input:\tpat\t\t\t\tpatlen := pat.length\t\tdelta1 := array[256] // 把所有字符表都遍历一遍, array 从1开始\t\tj := 1;loop:\t\tdelta1[j] := patlen\t\tj := j + 1\t\tif j &lt;= 256 then goto loop\t\tj := 1;delta:\t\tdelta1[pat[j]] := patlen - j\t\tif j &lt;= patlen then goto delta\t\t</code></pre><h3 id=\"delta2的构造\">delta2的构造</h3><p>我们先构造rpr表，即对每一个后缀找到the rightmost plausible reoccurrence.这里论文中没有给出明确的方案，这里搜寻了下<a href=\"https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\">wiki</a>采用wiki里提到的delta2的实现方案，并且只考虑rpr的情况。这里统一下标从1开始计算。</p><pre><code>suffix_length: // 算出在pos处最长后缀的长度input:\tpat, pos\t\tpatlen := pat.length\t\ti := 0\t\tloop:\tif (pat[pos-i] == word[patlen-i]) and ( i&lt; pos) then\t\t\t++i\t\t\tgoto loop\t\t\t\t\treturn i</code></pre><pre><code>make_delta2:input:\tpat\t\tpatlen := pat.length\t\tp := 1\t\tloop:\t\t\tif p &lt; patlen then\t\t\tslen := suffix_length(pat, p)\t\t\tif ((p-slen &lt;=0) or // 这里加个前序不存在的判定,wiki里这种情况通过loop1考虑了\t\t\t\t(pat[p-slen] != pat[patlen - slen]) then\t\t\t\tdelta2[patlen - slen] = patlen - p + slen\t\t\tp ++\t\t\tgoto loop</code></pre><h2 id=\"实现细节\">实现细节</h2><p>使用delta0替换delta1，<code>delta0(pat(patlen)) := large := stringlen + patlen + 1</code></p><pre><code>input: \tstring, pat\t\tstringlen := string.length\t\tpatlen := pat.length\t\ti := patlen\t\tif i &gt; stringlen then return falsefast:\t\t\ti := i + delta0(string(i))\t\tif i&lt;= stringlen then goto fastundo:\tif i &lt;= large then \treturn false\t\ti := (i - large) -1\t\tj := patlen -1slow:\tif j == 0 return i + 1\t\tif string(i) == pat(j)\t\t\tthen \t\t\tj := j-1\t\t\ti := i-1\t\t\tgoto slow\t\t\tclose\t\ti := i + max(delta1(string(i)), delta2(j))\t\tgoto fast\t\t\t</code></pre><p>这部分代码比较难理解。是作者为了优化算法速度做的实现，原理与之前的版本是一致的。这里细细剖析下。</p><p>首先看下<code>fast</code>循环进来和结束的状态与条件：</p><ul>  <li>程序开始时进入，此时<code>i &lt;= stringlen</code>，或者确切的说<code>i := patlen</code>。进入<code>fast</code>后运行<code>i := i + string(patlen)</code>。    <ul>      <li>如果，<code>string(patlen)</code>与<code>pat(patlen)</code>不相等，此时右移到下一次匹配的位置；</li>      <li>如果，<code>string(patlen)</code>与<code>pat(patlen)</code>相等，此时右移large；</li>      <li>判断 <code>i &lt;= stringlen</code>，如果<code>i &gt; stringlen</code>，并且<code>i &gt; large</code>，这说明我们的末尾字符匹配成功，可以进入<code>slow</code>逻辑继续匹配。</li>      <li>如果<code>i&gt; stringlen</code>,但<code>i &lt;= large</code>，这说明，我们末尾字符没有匹配成功，但是<code>i</code>移出了string的范围，匹配失败。</li>    </ul>  </li>  <li>从<code>slow</code>中进入，此时<code>string(i) != pat(j)</code>，出现了第一次不匹配，<code>i</code>更新为<code>i + max(delta1(string(i)), delta2(j))</code>，注意这里，使用的仍然是<code>delta1</code>。</li></ul><p><code>slow</code>的逻辑与原版算法基本一致。</p><p>这版算法将对<code>patlen</code>处字符的匹配单独提出，作者评估过80%的匹配时间都消耗在<code>fast</code>loop，通过将这部分代码单独提出，使用机器指令单独编码，可以加快算法的运行速度。</p><h2 id=\"理论分析\">理论分析</h2><p>这部分见论文吧，通过概率模型分析，运行时间是c*(i + patlen) c&lt; 1。</p><h2 id=\"代码实现\">代码实现</h2><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;void make_delta1(const char* pat, int patlen, int* delta1){\t\tfor(int i = 0; i &lt; 256; ++i)\t{\t\tdelta1[i] = patlen;\t}\tfor(int i = 0; i &lt; patlen; ++i)\t{\t\tdelta1[(int)pat[i]] = patlen - i -1; // we start index from zero\t\t}}int suffix_length(const char* pat, int patlen,int pos){\tint i = 0;\twhile( i &lt;= pos \t\t\t&amp;&amp; pat[pos-i] == pat[patlen-i-1])\t{\t\t\t++i;\t\t\t\t}\treturn i;}void make_delta2(const char* pat, int patlen, int* delta2){\t\t// 默认正在p处不匹配时，直接移动到+1的位置进行新的匹配，\t// 最慢的\t// 默认值\tfor(int p = 0; p &lt; patlen; ++p)\t{\t\tdelta2[p] = patlen - p ;\t}\tfor(int p = 0; p &lt; patlen-1;++p)\t{\t\tint slen = suffix_length(pat, patlen, p);\t\t\t\tif(p - slen &lt; 0 || pat[p-slen] != pat[patlen-slen])\t\t{\t\t\tdelta2[patlen-slen -1] = patlen - p -1 + slen;\t\t\t//std::cout&lt;&lt;\" set delta2 \"&lt;&lt;patlen-slen -1 &lt;&lt; \" = \"&lt;&lt;patlen-p-1 + slen&lt;&lt;std::endl;\t\t}\t}}int match(const char* txt, int txtLen, const char* pat, int patlen){\t\t\t\tint delta1[256];\t\tmake_delta1(pat, patlen, delta1);\t\t\t\tint* delta2 = new int[patlen];\t\tmake_delta2(pat, patlen, delta2);\t\t\t\tint j = patlen-1;\t\tint i = patlen - 1;\t\twhile( i &lt; txtLen)\t\t{\t\t\tint j = patlen-1;\t\t\t//std::cout&lt;&lt;\" i = \"&lt;&lt;i&lt;&lt;\" j = \"&lt;&lt;j&lt;&lt;std::endl;\t\t\twhile( j &gt;= 0)\t\t\t{\t\t\t\t//std::cout&lt;&lt;\" compare \"&lt;&lt;txt[i] &lt;&lt; \" and \"&lt;&lt;pat[j]&lt;&lt;std::endl;\t\t\t\tif(txt[i] == pat[j])\t\t\t\t{\t\t\t\t\tj--;\t\t\t\t\ti--;\t\t\t\t}\t\t\t\telse{\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tif(j &lt;0)\t\t\t{\t\t\t\treturn i + 1;\t\t\t}\t\t\t//std::cout&lt;&lt;\" delta1 = \"&lt;&lt;delta1[txt[i]] &lt;&lt; \" delta2 = \"&lt;&lt;delta2[j]&lt;&lt;std::endl;\t\t\ti = i + std::max(delta1[txt[i]],delta2[j]);\t\t}\t\treturn -1;}</code></pre><h2 id=\"附\">附</h2><p>在 “Knuth D.E. Morris J.H., and Pratt, V.R. Fast pattern matching in strings”中Knuth提出了线性时间构造delta2的方法。参考论文<a href=\"https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf\">“A Fast String Searching Algorithm”</a></p>",
            "url": "http://localhost:4000/2020/01/04/faststringsearch",
            
            
            
            
            
            "date_published": "2020-01-04T00:00:00+08:00",
            "date_modified": "2020-01-04T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/01/03/redblacktre",
            "title": "红黑树",
            "summary": null,
            "content_text": "本篇文章的目的，学习红黑树。使用教材，”Introduction to Algorithms 3rd”。##综述首先，红黑树的五种属性：  每个节点必然时红色或者黑色；  根节点是黑色；  每个叶子节点也是黑色；  如果一个节点是红色，那么它的子节点必然是黑色；  对每个节点从根节点到后代叶子节点的路径上有同样多的黑色节点；黑高度 : 对每个节点x到其后代叶子节点的路径上黑节点的数量，但不包括x本身，记作bh(x).我们将根节点的黑高度记作红黑树的黑高度。Lemma 1 内部节点数为n的红黑树树高最多2lg(n+1).简单的证明：  对任一节点x来说至少有pow(2,bh(x)) -1个内部节点,这点可以用归纳法证明  由属性4，对于树高为h的红黑树，除了根节点外至少有h/2的节点为黑。##旋转旋转分为左旋和右旋。左旋x节点，z的左子节点接到x的右侧，x接到z的左侧。   右旋x节点，y的右子节点接到x的左侧，x接到y的右侧。 Left-Rotate(T,x)    y = x.right     x.right = y.left    if y.left != T.nil        y.left.p = x    y.p = x.p    if x.p == T.nil        T.root = y    elseif x == x.p.left        x.p.left = y    elseif x == x.p.right        x.p.right = y    y.left = x    x.p = yRight-Rotate(T,y)    x = y.left    y.left = x.right;    if x.right != T.nil        x.right.p = y    x.p = y.p    if y.p == T.nil        T.root = x    elseif y == y.p.left        y.p.left = x    elseif y == y.p.right        y.p.right = x    x.right = y    y.p = x插入RB-INSERT(T,z)    y = T.nil    x = T.root    while x != T.nil        y = x        if z.key &lt; x.key            x = x.left        else x= x.right    z.p = y    if y == T.nil        T.root = z    elseif z.key &lt; y.key        y.left = z    else y.right = z    z.left = T.nil    z.right = T.nil    z.color = RED    RB-INSERT-FIXUP(T,z)对于RB-INSERT-FIXUP，考虑插入z后,由于z为红色，只有属性2和4可能不满足。  属性2不满足的情况在于， z插入后为根节点；  属性4不满足的情况在于，z插入后，z的父节点也为红色。插入操作保持循环不变性：a. 节点z是红色节点；b. 如果z.p是根节点，那么z.p必然是黑色；c. 树的插入至多只会导致一条属性不满足。循环不变性的证明：Initialization:    a. 在开始时，z作为红色节点插入；    b. 如果z.p是根节点，那么根节点必然时黑节点；    c. 如果属性2不满足，那么z必然是作为根节点插入的,且此时只有可能这一条属性不满足；如果    属性4 不满足，则此时z.p与z均是红节点，同样只有可能这一条熟悉不满足。Termination:    a. 循环只会在节点z的父亲z.p未黑色节点时结束，通过在循环结束时将树根节点设置为黑色，属性2与4就都满足了。Maintenance:    如果插入后，属性4不满足，z.p为红色，那么z.p.p必然为黑节点。   case 1: z的叔叔节点是红色。 z.p与y均为红色节点。此时我们将z.p与y均染成黑色，将   z.p.p染成红色，那么对于z来说，可保持属性4和属性5。新的可能出现问题的节点上移到z.p.p。   case 2: z的叔叔节点是黑色，此时z是右孩子。   case 3: z的叔叔节点是黑色，此时z是左孩子。   对于情形2，我们对z.p左旋，从而将情形2化为情形3。此时z是左孩子，z与z.p均为红色，z的叔叔节点y时黑色，z.p.p不变。   我们将z.p染成黑色，z.p.p染成红色，然后右旋z.p.p。此时z.p变成黑色，属性2与4均满足，我们将z.p.p染成红色后，黑高减一，但现在我们将z.p染成黑色，黑高加一，于是属性5满足。具体算法如下：RB-INSERT-FIXUP(T,z)    while z.p.color == RED        if z.p == z.p.p.left            y = z.p.p.right            if y.color == RED               // case 1                z.p.color = BLACK                y.color = BLACK                z.p.p.color = RED                z = z.p.p            else                if z == z.p.right          // case 2                    z = z.p                    Left-Rotate(T,z)                z.p.color = BLACK          // case 3                z.p.p.color = RED          // case 3                 Right-Rotate(T,z.p.p)        else                               // z.p == z.p.p.right            y = z.p.p.left            if y.color == RED              // case 1'                z.p.color = BLACK                y.color = BLACK                z.p.p.color = RED                z= z.p.p            else                if z == z.p.left           // case 2'                    z = z.p                    Right-Rotate(T,z)                z.p.color = BLACK          // case 3'                z.p.p.color = RED          // case 3'                Left-Rotate(T,z.p.p)    T.root.color = BLACK分析对于有n个内部节点的红黑树，数高最多为O(lgn),那么RB-INSERT-FIXUP中while循环最多执行logn次，并且每次最多执行两次旋转。删除RB-TRANSPLANT(T,u,v)    if u.p == T.nil        T.root = v    elseif u == u.p.left        u.p.left = v    else        u.p.right ==v    v.p = u.pRB-Delete(T,z)    y = z    y-original-color = y.color    if z.left == T.nil        x = z.right        RB-TRANSPLANT(T,z,z.right)    elseif z.right == T.nil        x = z.left        RB-TRANSPLANT(T,z,z.left)    else        y = TREE-MINIMUM(z.right) // y 是z的直接后继        y-original-color = y.color        x = y.right        if y.p == z            x.p = y        else             RB-TRANSPLANT(T,y,y.right)            y.right = z.right            y.right.p = y        RB-TRANSPLANT(T,z,y)        y.left = z.left        y.left.p = y        y.color = z.color    if y-original-color == BLACK        RB-DELETE-FIXUP(T,x)删除操作的解析。  变量y用来记录准备删除或移动的节点。当z没有孩子或只有一个孩子时，y设置为z，我们直接删除y；当z有两个孩子时，我们将y设置为z的后置节点，将y移动到z的位置。  由于节点y的颜色可能发生变化，我们记录y的原本颜色，并在删除操作结束时判断是否需要RB-DELETE-FIXUP。  由于y节点的移动，我们需要在y原来的位置填补新的节点，由以上讨论知道，y最多只有一个节点。我们将这个节点记作x，x节点或者是y的唯一子节点，或者是T.nil，我们将x移动到y原来的位置。这里需要注意的是，如果z的直接后继y的父亲节点就是z的子节点，此时x节点填补y移动后的位置应该将y作为父节点，而不是将y.p作为父节点，作为y.p的z会被我们删除。  如果y是黑色，我们删除或者移动y都有可能造成红黑树属性不满足，我们必须在最后调用RB-DELETE-FIXUP进行修复。          如果y是根节点，删除后y的一个红色子节点变成新的根，属性2不满足；      如果x与x.p均为红色，属性4不满足；      将y移动到z的位置后，原先包括y的路径会少一个黑高，属性5不满足。      先来考虑属性5不满足的情况。由于y作为一个黑色节点被删除或移动，x顶替y的位置，原先包含y的简单路径上的树高减一。我们直接将这个额外的树高赋给x，于是现在变成属性1不满足了,并且不满足的节点只有x，我们对此做处理：  如果x是RED-BLACK节点，我们简单的将x染成黑色，属性1满足。此时bh(x)不变。  如果x是BLACK-BLACK节点，且是根节点，我们将这个额外的黑色移除。于是总体树的黑高减一,属性1满足，属性5满足。  如果x是BLACK-BLACK节点，且不是根节点，我们需要做旋转。          情形1,x的兄弟节点w是红节点。于是x必然有黑色的子节点，x.p必为黑色。我们将x.p的颜色与w的颜色互换，然后左旋x.p，此时，x的兄弟节点就变成黑色了,并且此时保持属性5不变。      情形2，x的兄弟节点w是黑节点。w的子节点均是黑节点。我们将x与w均染红，将多出的黑色给于x的父节点x.p。此时x.p变成新的x继续处理。      情形3，x的兄弟节点w是黑节点。w的左子节点是红，右子节点是黑色。我们将w的左子节点与w的颜色互换，并右旋w，这样就变成情形4。      情形4，x的兄弟节点w是黑节点。w的右子节点是红色。我们将w与w.p的颜色互换。将w的右节点颜色置为黑色，并左旋x.p。这样，我们可以将x的BLACK-BLACK变成BLACK即可。对于属性4和属性2不满足，我们简单的将x置黑即可。              RB-DELETE-FIXUP(T,x)    while x != T.root and x.color == BLACK        if x == x.p.left            w = x.p.right            if w.color == RED       // case 1                w.color = BLACK                x.p.color = RED     // case 1                LEFT-ROTATE(T,x.p)                w = x.p.right            if w.left.color == BLACK and w.right.color == BLACK                 w.color = RED                x = x.p             // case 2            else if w.right.color == BLACK      // case 3                    w.left.color = BLACK                    w.color = RED                    RIGHT-ROTATE(T,w)                    w = x.p.right                w.color = x.p.color             // case 4                x.p.color = BLACK                w.right.color = BLACK                LEFT-ROTATE(T,x.p)                x = T.root        else                        // 此时x是右节点            w = x.p.left            if w.color == RED       // case 1'                w.color = BLACK     // 互换颜色                x.p.color = RED     // case 1'                RIGHT-ROTATE(T,x.p)                w = x.p.left            if w.left.color == BLACK and w.right.color == BLACK                w.color = RED                x = x.p             // case 2'            else if w.left.color == BLACK       // case 3'                    w.right.color = BLACK                    w.color = RED                    LEFT-ROTATE(T,w)                    w = x.p.left               w.color = x.p.color          // case 4'               x.p.color = BLACK               w.left.color = BLACK               RIGHT-ROTATE(T,x.p)               x = T.root                   // terminate        x.color = BLACK                     // set root to BLACK分析只有情形2会造成whilte循环重入,并且整个删除周期最多只会做三次旋转，对于有n个内部节点的树来说，树高最多为O(lgn)，于是删除时间最多为O(lgn)。代码#ifndef __RED_BLACK_TREE_H__#define __RED_BLACK_TREE_H__ 1#include &lt;iostream&gt;#include &lt;queue&gt;const int RED = 0;const int BLACK = 1;const int BLACK_BLACK= 3;const int BLACK_RED = 4;template&lt;class T&gt;class BinNode{public:    BinNode (const T&amp; data)        :_data(data)    {        _color = BLACK;        _lc = NULL;        _rc = NULL;        _p = NULL;    }    virtual ~BinNode (){}    int &amp; color() {return _color;}    BinNode*&amp; lc(){return _lc;}    BinNode*&amp; rc(){return _rc;}    BinNode*&amp; p(){return _p;}    T&amp; data(){return _data;}private:private:    /* data */    int _color;    BinNode* _lc;    BinNode* _rc;    BinNode* _p;    T _data;};template&lt;class T&gt;class BinTree{    public:        static BinNode&lt;T&gt;* nil;    public:        BinTree()        {            _root = nil;        }        void insert(BinNode&lt;T&gt;* node);        BinNode&lt;T&gt;* search(const T &amp; t) const;        void deletenode(BinNode&lt;T&gt;* z);        void dfs();        void bfs();        BinNode&lt;T&gt;* root(){return _root;}        void LeftRotate(BinNode&lt;T&gt;* x) {left_rotate(x);}        void RightRotate(BinNode&lt;T&gt;* x){right_rotate(x);}    private:        BinNode&lt;T&gt;* search_recur(BinNode&lt;T&gt;* node, const T&amp; t) const;        void insert_fixup(BinNode&lt;T&gt;* node);        void left_rotate(BinNode&lt;T&gt;* x);        void right_rotate(BinNode&lt;T&gt;* x);        void transplant(BinNode&lt;T&gt;* u, BinNode&lt;T&gt;* v);        BinNode&lt;T&gt;* minimum(BinNode&lt;T&gt;* node);        void delete_fixup(BinNode&lt;T&gt;* x);        void dfs_recur(BinNode&lt;T&gt;* node);            private:        BinNode&lt;T&gt;* _root;    public:        static BinNode&lt;T&gt;* make_node(const T&amp; t)        {            BinNode&lt;T&gt;* node = new BinNode&lt;T&gt;(t);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;        }};template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::nil = new BinNode&lt;T&gt;(-1);template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::search(const T&amp; t) const{    return search_recur(_root, t);}template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::search_recur(BinNode&lt;T&gt;* node, const T&amp; t) const{    if(node == nil) return nil;    if(node-&gt;data() == t) return node;    if(node-&gt;data() &lt; t)    {        return search_recur(node-&gt;rc(),t);    }    if (node-&gt;data() &gt; t)    {        return search_recur(node-&gt;lc(),t);    }    return nil;}template&lt;class T&gt;void BinTree&lt;T&gt;::dfs(){    dfs_recur(_root);}static const char* getColor(int color){    if (color == RED)    {        return \"red\";    }    else if(color == BLACK)    {        return \"black\";    }    else if(color == BLACK_BLACK)    {        return \"black_black\";    }    else if(color == BLACK_RED)    {        return \"black_red\";    }    return \"\";}template &lt;class T&gt;void BinTree&lt;T&gt;::bfs(){    if (_root == nil) return;    std::queue&lt;BinNode&lt;T&gt;* &gt; q;    q.push(_root);    int cur = 1;    int next =0;    while(q.size() &gt; 0)    {        BinNode&lt;T&gt;* node = q.front();        q.pop();        std::cout&lt;&lt;node-&gt;data() &lt;&lt; \" \"&lt;&lt;getColor(node-&gt;color())&lt;&lt;\"    \";        if(node-&gt;lc() != NULL)        {            q.push(node-&gt;lc());            next ++;        }        if(node-&gt;rc() != NULL)        {            q.push(node-&gt;rc());            next += 1;        }        cur--;        if(cur &lt;=0)        {            std::cout&lt;&lt;std::endl;            cur = next;            next = 0;        }    }    std::cout&lt;&lt;std::endl;}    template&lt;class T&gt;void BinTree&lt;T&gt;::dfs_recur(BinNode&lt;T&gt;* node){    if(node-&gt;lc() != nil)    {        dfs_recur(node-&gt;lc());    }    if(node-&gt;rc() != nil)    {        dfs_recur(node-&gt;rc());    }    std::cout&lt;&lt;\" \"&lt;&lt;node-&gt;data()&lt;&lt;\" \";}    template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::minimum(BinNode&lt;T&gt;* node){    while(node-&gt;lc() != nil)    {        node = node-&gt;lc();    }    return node;}    template&lt;class T&gt;void BinTree&lt;T&gt;::transplant(BinNode&lt;T&gt;* u, BinNode&lt;T&gt;* v){    if(u-&gt;p() == nil)    {        _root = v;    }    else if(u == u-&gt;p()-&gt;lc())    {        u-&gt;p()-&gt;lc() = v;    }    else    {        u-&gt;p()-&gt;rc() = v;    }    v-&gt;p() = u-&gt;p();}    template&lt;class T&gt;void BinTree&lt;T&gt;::deletenode(BinNode&lt;T&gt;* z){    BinNode&lt;T&gt;* y = z;    BinNode&lt;T&gt;* x= nil;    int y_original_color = y-&gt;color();    if (z-&gt;lc() == nil)    {        x = z-&gt;rc();        transplant(z,z-&gt;rc());    }    else if(z-&gt;rc() == nil)    {        x = z-&gt;lc();        transplant(z,z-&gt;lc());    }    else    {        y = minimum(z-&gt;rc());        y_original_color = y-&gt;color();        x = y-&gt;rc();        if(y-&gt;p() == z)        {            x-&gt;p() = y;        }        else        {            transplant(y,y-&gt;rc());            y-&gt;rc() = z-&gt;rc();            y-&gt;rc()-&gt;p() = y;        }        transplant(z,y);        y-&gt;lc() = z-&gt;lc();        y-&gt;lc()-&gt;p() = y;        y-&gt;color() = z-&gt;color();    }    if(y_original_color == BLACK)    {        std::cout&lt;&lt;\"delete_fixup \"&lt;&lt;x-&gt;data()&lt;&lt;std::endl;        delete_fixup(x);    }}    template&lt;class T&gt;void BinTree&lt;T&gt;::delete_fixup(BinNode&lt;T&gt;* x){    BinNode&lt;T&gt; * w;    while( x != _root &amp;&amp; x-&gt;color() == BLACK)    {        if(x == x-&gt;p()-&gt;lc())        {            w = x-&gt;p()-&gt;rc();            if(w-&gt;color() == RED) // case 1            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                w = x-&gt;p()-&gt;rc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;rc()-&gt;color() == BLACK)                {                    w-&gt;lc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    right_rotate(w);                    w = x-&gt;p()-&gt;rc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color()  = BLACK;                w-&gt;rc()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                x = _root;            }        }        else        {            w = x-&gt;p()-&gt;lc();            if(w-&gt;color() == RED)            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = RED;                right_rotate(x-&gt;p());                w = x-&gt;p()-&gt;lc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;lc()-&gt;color() == BLACK)                {                    w-&gt;rc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    left_rotate(w);                    w = x-&gt;p()-&gt;lc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color() = BLACK;                w-&gt;lc()-&gt;color() = BLACK;                right_rotate(x-&gt;p());                x = _root;            }        }    }    x-&gt;color() =BLACK;}    template&lt;class T&gt;void BinTree&lt;T&gt;::left_rotate(BinNode&lt;T&gt;* x){    BinNode&lt;T&gt;* y = x-&gt;rc();    x-&gt;rc() = y-&gt;lc();    if(y-&gt;lc() != nil)    {        y-&gt;lc()-&gt;p() = x;    }    y-&gt;p() = x-&gt;p();    if(x-&gt;p() == nil)    {        _root = y;    }    else if (x == x-&gt;p()-&gt;lc())    {        x-&gt;p()-&gt;lc() = y;    }    else if(x == x-&gt;p()-&gt;rc())    {        x-&gt;p()-&gt;rc() = y;    }    y-&gt;lc() = x;    x-&gt;p() = y;}template&lt;class T&gt;void BinTree&lt;T&gt;::right_rotate(BinNode&lt;T&gt;* y){    BinNode&lt;T&gt;* x = y-&gt;lc();    y-&gt;lc()  = x-&gt;rc();    if(x-&gt;rc() != nil)    {        x-&gt;rc()-&gt;p() = y;    }    x-&gt;p() = y-&gt;p();    if(y-&gt;p() == nil)    {        _root = x;    }    else if(y == y-&gt;p()-&gt;lc())    {        y-&gt;p()-&gt;lc() = x;    }    else if(y == y-&gt;p()-&gt;rc())    {        y-&gt;p()-&gt;rc() =x;    }    x -&gt;rc() = y;    y-&gt;p() = x;}    template&lt;class T&gt;void BinTree&lt;T&gt;::insert_fixup(BinNode&lt;T&gt;* z){    BinNode&lt;T&gt;* y;    while(z-&gt;p()-&gt;color() == RED)    {        if(z-&gt;p() == z-&gt;p()-&gt;p()-&gt;lc())        {            y = z-&gt;p()-&gt;p()-&gt;rc();            if (y-&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if(z == z-&gt;p()-&gt;rc())                {                    z = z-&gt;p();                    left_rotate(z);                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                right_rotate(z-&gt;p()-&gt;p());            }        }        else        {            //std::cout&lt;&lt;\"case 2'\"&lt;&lt;std::endl;            y = z-&gt;p()-&gt;p()-&gt;lc();            if (y -&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if (z == z-&gt;p()-&gt;lc())                {                    z = z-&gt;p();                    right_rotate(z);                    //std::cout&lt;&lt;\"right_rotate for case 2\"&lt;&lt;std::endl;                    //bfs();                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                left_rotate(z-&gt;p()-&gt;p());            }        }    }    _root-&gt;color() = BLACK;}    template&lt;class T&gt;void BinTree&lt;T&gt;::insert(BinNode&lt;T&gt;* node){    BinNode&lt;T&gt;* y = nil;    BinNode&lt;T&gt;* x= _root;;    while (x != nil)    {        y = x;        if(node-&gt;data() &lt; x-&gt;data())        {            x = x-&gt;lc();        }        else        {            x = x-&gt;rc();        }    }    node-&gt;p() = y;    if (y == nil )    {        _root = node;    }    else if(node-&gt;data() &lt; y-&gt;data())    {        y-&gt;lc() = node;    }    else    {        y-&gt;rc() = node;    }    node-&gt;lc() = nil;    node-&gt;rc() = nil;    node-&gt;color() = RED;    //std::cout&lt;&lt;\"before insert_fixup \"&lt;&lt;std::endl;    //bfs();    //std::cout&lt;&lt;\"===================\"&lt;&lt;std::endl;    insert_fixup(node);}#endif /* ifndef __RED_BLACK_TREE_H__*/",
            "content_html": "<p>本篇文章的目的，学习红黑树。使用教材，”Introduction to Algorithms 3rd”。</p><!--more--><p>##综述首先，红黑树的五种属性：</p><ol>  <li>每个节点必然时红色或者黑色；</li>  <li>根节点是黑色；</li>  <li>每个叶子节点也是黑色；</li>  <li>如果一个节点是红色，那么它的子节点必然是黑色；</li>  <li>对每个节点从根节点到后代叶子节点的路径上有同样多的黑色节点；</li></ol><p><strong>黑高度</strong> : 对每个节点x到其后代叶子节点的路径上黑节点的数量，但不包括x本身，记作bh(x).我们将根节点的黑高度记作红黑树的黑高度。</p><p><strong>Lemma 1</strong> 内部节点数为n的红黑树树高最多2lg(n+1).</p><p>简单的证明：</p><ul>  <li>对任一节点x来说至少有pow(2,bh(x)) -1个内部节点,这点可以用归纳法证明</li>  <li>由属性4，对于树高为h的红黑树，除了根节点外至少有h/2的节点为黑。</li></ul><p>##旋转旋转分为左旋和右旋。</p><p>左旋x节点，z的左子节点接到x的右侧，x接到z的左侧。</p><p><img src=\"/assets/redblacktree/left_rotate_left.png\" alt=\"operation 1\" />   <img src=\"/assets/redblacktree/left_rotate_right.png\" alt=\"operation 2\" /></p><p>右旋x节点，y的右子节点接到x的左侧，x接到y的右侧。</p><p><img src=\"/assets/redblacktree/left_rotate_left.png\" alt=\"operation 1\" /> <img src=\"/assets/redblacktree/right_rotate_right.png\" alt=\"operation 3\" /></p><pre><code>Left-Rotate(T,x)    y = x.right     x.right = y.left    if y.left != T.nil        y.left.p = x    y.p = x.p    if x.p == T.nil        T.root = y    elseif x == x.p.left        x.p.left = y    elseif x == x.p.right        x.p.right = y    y.left = x    x.p = y</code></pre><pre><code>Right-Rotate(T,y)    x = y.left    y.left = x.right;    if x.right != T.nil        x.right.p = y    x.p = y.p    if y.p == T.nil        T.root = x    elseif y == y.p.left        y.p.left = x    elseif y == y.p.right        y.p.right = x    x.right = y    y.p = x</code></pre><h2 id=\"插入\">插入</h2><pre><code>RB-INSERT(T,z)    y = T.nil    x = T.root    while x != T.nil        y = x        if z.key &lt; x.key            x = x.left        else x= x.right    z.p = y    if y == T.nil        T.root = z    elseif z.key &lt; y.key        y.left = z    else y.right = z    z.left = T.nil    z.right = T.nil    z.color = RED    RB-INSERT-FIXUP(T,z)</code></pre><p>对于<code>RB-INSERT-FIXUP</code>，考虑插入z后,由于z为红色，只有属性2和4可能不满足。</p><ul>  <li>属性2不满足的情况在于， z插入后为根节点；</li>  <li>属性4不满足的情况在于，z插入后，z的父节点也为红色。</li></ul><p>插入操作保持循环不变性：a. 节点z是红色节点；b. 如果z.p是根节点，那么z.p必然是黑色；c. 树的插入至多只会导致一条属性不满足。</p><p>循环不变性的证明：</p><pre><code>Initialization:    a. 在开始时，z作为红色节点插入；    b. 如果z.p是根节点，那么根节点必然时黑节点；    c. 如果属性2不满足，那么z必然是作为根节点插入的,且此时只有可能这一条属性不满足；如果    属性4 不满足，则此时z.p与z均是红节点，同样只有可能这一条熟悉不满足。Termination:    a. 循环只会在节点z的父亲z.p未黑色节点时结束，通过在循环结束时将树根节点设置为黑色，属性2与4就都满足了。Maintenance:    如果插入后，属性4不满足，z.p为红色，那么z.p.p必然为黑节点。   case 1: z的叔叔节点是红色。 z.p与y均为红色节点。此时我们将z.p与y均染成黑色，将   z.p.p染成红色，那么对于z来说，可保持属性4和属性5。新的可能出现问题的节点上移到z.p.p。   case 2: z的叔叔节点是黑色，此时z是右孩子。   case 3: z的叔叔节点是黑色，此时z是左孩子。   对于情形2，我们对z.p左旋，从而将情形2化为情形3。此时z是左孩子，z与z.p均为红色，z的叔叔节点y时黑色，z.p.p不变。   我们将z.p染成黑色，z.p.p染成红色，然后右旋z.p.p。此时z.p变成黑色，属性2与4均满足，我们将z.p.p染成红色后，黑高减一，但现在我们将z.p染成黑色，黑高加一，于是属性5满足。</code></pre><p><img src=\"/assets/redblacktree/insert_case1_left.png\" alt=\"operation 2\" /><img src=\"/assets/redblacktree/insert_case2.png\" alt=\"operation 3\" />具体算法如下：</p><pre><code>RB-INSERT-FIXUP(T,z)    while z.p.color == RED        if z.p == z.p.p.left            y = z.p.p.right            if y.color == RED               // case 1                z.p.color = BLACK                y.color = BLACK                z.p.p.color = RED                z = z.p.p            else                if z == z.p.right          // case 2                    z = z.p                    Left-Rotate(T,z)                z.p.color = BLACK          // case 3                z.p.p.color = RED          // case 3                 Right-Rotate(T,z.p.p)        else                               // z.p == z.p.p.right            y = z.p.p.left            if y.color == RED              // case 1'                z.p.color = BLACK                y.color = BLACK                z.p.p.color = RED                z= z.p.p            else                if z == z.p.left           // case 2'                    z = z.p                    Right-Rotate(T,z)                z.p.color = BLACK          // case 3'                z.p.p.color = RED          // case 3'                Left-Rotate(T,z.p.p)    T.root.color = BLACK</code></pre><p>分析</p><p>对于有n个内部节点的红黑树，数高最多为O(lgn),那么<code>RB-INSERT-FIXUP</code>中<code>while</code>循环最多执行logn次，并且每次最多执行两次旋转。</p><h2 id=\"删除\">删除</h2><pre><code>RB-TRANSPLANT(T,u,v)    if u.p == T.nil        T.root = v    elseif u == u.p.left        u.p.left = v    else        u.p.right ==v    v.p = u.p</code></pre><pre><code>RB-Delete(T,z)    y = z    y-original-color = y.color    if z.left == T.nil        x = z.right        RB-TRANSPLANT(T,z,z.right)    elseif z.right == T.nil        x = z.left        RB-TRANSPLANT(T,z,z.left)    else        y = TREE-MINIMUM(z.right) // y 是z的直接后继        y-original-color = y.color        x = y.right        if y.p == z            x.p = y        else             RB-TRANSPLANT(T,y,y.right)            y.right = z.right            y.right.p = y        RB-TRANSPLANT(T,z,y)        y.left = z.left        y.left.p = y        y.color = z.color    if y-original-color == BLACK        RB-DELETE-FIXUP(T,x)</code></pre><p>删除操作的解析。</p><ul>  <li>变量y用来记录准备删除或移动的节点。当z没有孩子或只有一个孩子时，y设置为z，我们直接删除y；当z有两个孩子时，我们将y设置为z的后置节点，将y移动到z的位置。</li>  <li>由于节点y的颜色可能发生变化，我们记录y的原本颜色，并在删除操作结束时判断是否需要<code>RB-DELETE-FIXUP</code>。</li>  <li>由于y节点的移动，我们需要在y原来的位置填补新的节点，由以上讨论知道，y最多只有一个节点。我们将这个节点记作x，x节点或者是y的唯一子节点，或者是T.nil，我们将x移动到y原来的位置。这里需要注意的是，如果z的直接后继y的父亲节点就是z的子节点，此时x节点填补y移动后的位置应该将y作为父节点，而不是将y.p作为父节点，作为y.p的z会被我们删除。</li>  <li>如果y是黑色，我们删除或者移动y都有可能造成红黑树属性不满足，我们必须在最后调用<code>RB-DELETE-FIXUP</code>进行修复。    <ul>      <li>如果y是根节点，删除后y的一个红色子节点变成新的根，属性2不满足；</li>      <li>如果x与x.p均为红色，属性4不满足；</li>      <li>将y移动到z的位置后，原先包括y的路径会少一个黑高，属性5不满足。</li>    </ul>  </li></ul><p>先来考虑属性5不满足的情况。由于y作为一个黑色节点被删除或移动，x顶替y的位置，原先包含y的简单路径上的树高减一。我们直接将这个额外的树高赋给x，于是现在变成属性1不满足了,并且不满足的节点只有x，我们对此做处理：</p><ul>  <li>如果x是RED-BLACK节点，我们简单的将x染成黑色，属性1满足。此时bh(x)不变。</li>  <li>如果x是BLACK-BLACK节点，且是根节点，我们将这个额外的黑色移除。于是总体树的黑高减一,属性1满足，属性5满足。</li>  <li>如果x是BLACK-BLACK节点，且不是根节点，我们需要做旋转。    <ul>      <li>情形1,x的兄弟节点w是红节点。于是x必然有黑色的子节点，x.p必为黑色。我们将x.p的颜色与w的颜色互换，然后左旋x.p，此时，x的兄弟节点就变成黑色了,并且此时保持属性5不变。</li>      <li>情形2，x的兄弟节点w是黑节点。w的子节点均是黑节点。我们将x与w均染红，将多出的黑色给于x的父节点x.p。此时x.p变成新的x继续处理。</li>      <li>情形3，x的兄弟节点w是黑节点。w的左子节点是红，右子节点是黑色。我们将w的左子节点与w的颜色互换，并右旋w，这样就变成情形4。</li>      <li>情形4，x的兄弟节点w是黑节点。w的右子节点是红色。我们将w与w.p的颜色互换。将w的右节点颜色置为黑色，并左旋x.p。这样，我们可以将x的BLACK-BLACK变成BLACK即可。对于属性4和属性2不满足，我们简单的将x置黑即可。</li>    </ul>  </li></ul><p><img src=\"/assets/redblacktree/delete_fix_up.png\" alt=\"operation 4\" />   <img src=\"/assets/redblacktree/delete_fix_up_case_1_1.png\" alt=\"operation 4'\" /></p><p><img src=\"/assets/redblacktree/delete_fix_up_case2.png\" alt=\"operation 5\" />   <img src=\"/assets/redblacktree/delete_fix_up_case2_1.png\" alt=\"operation 5'\" /></p><p><img src=\"/assets/redblacktree/delete_fix_up_case3.png\" alt=\"operation 6\" /> <img src=\"/assets/redblacktree/delete_fix_up_case3_1.png\" alt=\"operation 6'\" /></p><p><img src=\"/assets/redblacktree/delete_fix_up_case4.png\" alt=\"operation 7\" /> <img src=\"/assets/redblacktree/delete_fix_up_case4_1.png\" alt=\"operation 7'\" /></p><pre><code>RB-DELETE-FIXUP(T,x)    while x != T.root and x.color == BLACK        if x == x.p.left            w = x.p.right            if w.color == RED       // case 1                w.color = BLACK                x.p.color = RED     // case 1                LEFT-ROTATE(T,x.p)                w = x.p.right            if w.left.color == BLACK and w.right.color == BLACK                 w.color = RED                x = x.p             // case 2            else if w.right.color == BLACK      // case 3                    w.left.color = BLACK                    w.color = RED                    RIGHT-ROTATE(T,w)                    w = x.p.right                w.color = x.p.color             // case 4                x.p.color = BLACK                w.right.color = BLACK                LEFT-ROTATE(T,x.p)                x = T.root        else                        // 此时x是右节点            w = x.p.left            if w.color == RED       // case 1'                w.color = BLACK     // 互换颜色                x.p.color = RED     // case 1'                RIGHT-ROTATE(T,x.p)                w = x.p.left            if w.left.color == BLACK and w.right.color == BLACK                w.color = RED                x = x.p             // case 2'            else if w.left.color == BLACK       // case 3'                    w.right.color = BLACK                    w.color = RED                    LEFT-ROTATE(T,w)                    w = x.p.left               w.color = x.p.color          // case 4'               x.p.color = BLACK               w.left.color = BLACK               RIGHT-ROTATE(T,x.p)               x = T.root                   // terminate        x.color = BLACK                     // set root to BLACK</code></pre><p>分析只有情形2会造成whilte循环重入,并且整个删除周期最多只会做三次旋转，对于有n个内部节点的树来说，树高最多为O(lgn)，于是删除时间最多为O(lgn)。</p><h2 id=\"代码\">代码</h2><pre><code>#ifndef __RED_BLACK_TREE_H__#define __RED_BLACK_TREE_H__ 1#include &lt;iostream&gt;#include &lt;queue&gt;const int RED = 0;const int BLACK = 1;const int BLACK_BLACK= 3;const int BLACK_RED = 4;template&lt;class T&gt;class BinNode{public:    BinNode (const T&amp; data)        :_data(data)    {        _color = BLACK;        _lc = NULL;        _rc = NULL;        _p = NULL;    }    virtual ~BinNode (){}    int &amp; color() {return _color;}    BinNode*&amp; lc(){return _lc;}    BinNode*&amp; rc(){return _rc;}    BinNode*&amp; p(){return _p;}    T&amp; data(){return _data;}private:private:    /* data */    int _color;    BinNode* _lc;    BinNode* _rc;    BinNode* _p;    T _data;};template&lt;class T&gt;class BinTree{    public:        static BinNode&lt;T&gt;* nil;    public:        BinTree()        {            _root = nil;        }        void insert(BinNode&lt;T&gt;* node);        BinNode&lt;T&gt;* search(const T &amp; t) const;        void deletenode(BinNode&lt;T&gt;* z);        void dfs();        void bfs();        BinNode&lt;T&gt;* root(){return _root;}        void LeftRotate(BinNode&lt;T&gt;* x) {left_rotate(x);}        void RightRotate(BinNode&lt;T&gt;* x){right_rotate(x);}    private:        BinNode&lt;T&gt;* search_recur(BinNode&lt;T&gt;* node, const T&amp; t) const;        void insert_fixup(BinNode&lt;T&gt;* node);        void left_rotate(BinNode&lt;T&gt;* x);        void right_rotate(BinNode&lt;T&gt;* x);        void transplant(BinNode&lt;T&gt;* u, BinNode&lt;T&gt;* v);        BinNode&lt;T&gt;* minimum(BinNode&lt;T&gt;* node);        void delete_fixup(BinNode&lt;T&gt;* x);        void dfs_recur(BinNode&lt;T&gt;* node);            private:        BinNode&lt;T&gt;* _root;    public:        static BinNode&lt;T&gt;* make_node(const T&amp; t)        {            BinNode&lt;T&gt;* node = new BinNode&lt;T&gt;(t);            node-&gt;color() = RED;            node-&gt;lc() = nil;            node-&gt;rc() = nil;            node-&gt;p() = nil;            return node;        }};template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::nil = new BinNode&lt;T&gt;(-1);template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::search(const T&amp; t) const{    return search_recur(_root, t);}template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::search_recur(BinNode&lt;T&gt;* node, const T&amp; t) const{    if(node == nil) return nil;    if(node-&gt;data() == t) return node;    if(node-&gt;data() &lt; t)    {        return search_recur(node-&gt;rc(),t);    }    if (node-&gt;data() &gt; t)    {        return search_recur(node-&gt;lc(),t);    }    return nil;}template&lt;class T&gt;void BinTree&lt;T&gt;::dfs(){    dfs_recur(_root);}static const char* getColor(int color){    if (color == RED)    {        return \"red\";    }    else if(color == BLACK)    {        return \"black\";    }    else if(color == BLACK_BLACK)    {        return \"black_black\";    }    else if(color == BLACK_RED)    {        return \"black_red\";    }    return \"\";}template &lt;class T&gt;void BinTree&lt;T&gt;::bfs(){    if (_root == nil) return;    std::queue&lt;BinNode&lt;T&gt;* &gt; q;    q.push(_root);    int cur = 1;    int next =0;    while(q.size() &gt; 0)    {        BinNode&lt;T&gt;* node = q.front();        q.pop();        std::cout&lt;&lt;node-&gt;data() &lt;&lt; \" \"&lt;&lt;getColor(node-&gt;color())&lt;&lt;\"    \";        if(node-&gt;lc() != NULL)        {            q.push(node-&gt;lc());            next ++;        }        if(node-&gt;rc() != NULL)        {            q.push(node-&gt;rc());            next += 1;        }        cur--;        if(cur &lt;=0)        {            std::cout&lt;&lt;std::endl;            cur = next;            next = 0;        }    }    std::cout&lt;&lt;std::endl;}    template&lt;class T&gt;void BinTree&lt;T&gt;::dfs_recur(BinNode&lt;T&gt;* node){    if(node-&gt;lc() != nil)    {        dfs_recur(node-&gt;lc());    }    if(node-&gt;rc() != nil)    {        dfs_recur(node-&gt;rc());    }    std::cout&lt;&lt;\" \"&lt;&lt;node-&gt;data()&lt;&lt;\" \";}    template&lt;class T&gt;BinNode&lt;T&gt;* BinTree&lt;T&gt;::minimum(BinNode&lt;T&gt;* node){    while(node-&gt;lc() != nil)    {        node = node-&gt;lc();    }    return node;}    template&lt;class T&gt;void BinTree&lt;T&gt;::transplant(BinNode&lt;T&gt;* u, BinNode&lt;T&gt;* v){    if(u-&gt;p() == nil)    {        _root = v;    }    else if(u == u-&gt;p()-&gt;lc())    {        u-&gt;p()-&gt;lc() = v;    }    else    {        u-&gt;p()-&gt;rc() = v;    }    v-&gt;p() = u-&gt;p();}    template&lt;class T&gt;void BinTree&lt;T&gt;::deletenode(BinNode&lt;T&gt;* z){    BinNode&lt;T&gt;* y = z;    BinNode&lt;T&gt;* x= nil;    int y_original_color = y-&gt;color();    if (z-&gt;lc() == nil)    {        x = z-&gt;rc();        transplant(z,z-&gt;rc());    }    else if(z-&gt;rc() == nil)    {        x = z-&gt;lc();        transplant(z,z-&gt;lc());    }    else    {        y = minimum(z-&gt;rc());        y_original_color = y-&gt;color();        x = y-&gt;rc();        if(y-&gt;p() == z)        {            x-&gt;p() = y;        }        else        {            transplant(y,y-&gt;rc());            y-&gt;rc() = z-&gt;rc();            y-&gt;rc()-&gt;p() = y;        }        transplant(z,y);        y-&gt;lc() = z-&gt;lc();        y-&gt;lc()-&gt;p() = y;        y-&gt;color() = z-&gt;color();    }    if(y_original_color == BLACK)    {        std::cout&lt;&lt;\"delete_fixup \"&lt;&lt;x-&gt;data()&lt;&lt;std::endl;        delete_fixup(x);    }}    template&lt;class T&gt;void BinTree&lt;T&gt;::delete_fixup(BinNode&lt;T&gt;* x){    BinNode&lt;T&gt; * w;    while( x != _root &amp;&amp; x-&gt;color() == BLACK)    {        if(x == x-&gt;p()-&gt;lc())        {            w = x-&gt;p()-&gt;rc();            if(w-&gt;color() == RED) // case 1            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                w = x-&gt;p()-&gt;rc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;rc()-&gt;color() == BLACK)                {                    w-&gt;lc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    right_rotate(w);                    w = x-&gt;p()-&gt;rc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color()  = BLACK;                w-&gt;rc()-&gt;color() = BLACK;                left_rotate(x-&gt;p());                x = _root;            }        }        else        {            w = x-&gt;p()-&gt;lc();            if(w-&gt;color() == RED)            {                w-&gt;color() = BLACK;                x-&gt;p()-&gt;color() = RED;                right_rotate(x-&gt;p());                w = x-&gt;p()-&gt;lc();            }            if(w-&gt;lc()-&gt;color() == BLACK &amp;&amp; w-&gt;rc()-&gt;color() == BLACK)            {                w-&gt;color() = RED;                x = x-&gt;p();            }            else            {                if(w-&gt;lc()-&gt;color() == BLACK)                {                    w-&gt;rc()-&gt;color() = BLACK;                    w-&gt;color() = RED;                    left_rotate(w);                    w = x-&gt;p()-&gt;lc();                }                w-&gt;color() = x-&gt;p()-&gt;color();                x-&gt;p()-&gt;color() = BLACK;                w-&gt;lc()-&gt;color() = BLACK;                right_rotate(x-&gt;p());                x = _root;            }        }    }    x-&gt;color() =BLACK;}    template&lt;class T&gt;void BinTree&lt;T&gt;::left_rotate(BinNode&lt;T&gt;* x){    BinNode&lt;T&gt;* y = x-&gt;rc();    x-&gt;rc() = y-&gt;lc();    if(y-&gt;lc() != nil)    {        y-&gt;lc()-&gt;p() = x;    }    y-&gt;p() = x-&gt;p();    if(x-&gt;p() == nil)    {        _root = y;    }    else if (x == x-&gt;p()-&gt;lc())    {        x-&gt;p()-&gt;lc() = y;    }    else if(x == x-&gt;p()-&gt;rc())    {        x-&gt;p()-&gt;rc() = y;    }    y-&gt;lc() = x;    x-&gt;p() = y;}template&lt;class T&gt;void BinTree&lt;T&gt;::right_rotate(BinNode&lt;T&gt;* y){    BinNode&lt;T&gt;* x = y-&gt;lc();    y-&gt;lc()  = x-&gt;rc();    if(x-&gt;rc() != nil)    {        x-&gt;rc()-&gt;p() = y;    }    x-&gt;p() = y-&gt;p();    if(y-&gt;p() == nil)    {        _root = x;    }    else if(y == y-&gt;p()-&gt;lc())    {        y-&gt;p()-&gt;lc() = x;    }    else if(y == y-&gt;p()-&gt;rc())    {        y-&gt;p()-&gt;rc() =x;    }    x -&gt;rc() = y;    y-&gt;p() = x;}    template&lt;class T&gt;void BinTree&lt;T&gt;::insert_fixup(BinNode&lt;T&gt;* z){    BinNode&lt;T&gt;* y;    while(z-&gt;p()-&gt;color() == RED)    {        if(z-&gt;p() == z-&gt;p()-&gt;p()-&gt;lc())        {            y = z-&gt;p()-&gt;p()-&gt;rc();            if (y-&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if(z == z-&gt;p()-&gt;rc())                {                    z = z-&gt;p();                    left_rotate(z);                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                right_rotate(z-&gt;p()-&gt;p());            }        }        else        {            //std::cout&lt;&lt;\"case 2'\"&lt;&lt;std::endl;            y = z-&gt;p()-&gt;p()-&gt;lc();            if (y -&gt;color() == RED)            {                z-&gt;p()-&gt;color() = BLACK;                y-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                z = z-&gt;p()-&gt;p();            }            else            {                if (z == z-&gt;p()-&gt;lc())                {                    z = z-&gt;p();                    right_rotate(z);                    //std::cout&lt;&lt;\"right_rotate for case 2\"&lt;&lt;std::endl;                    //bfs();                }                z-&gt;p()-&gt;color() = BLACK;                z-&gt;p()-&gt;p()-&gt;color() = RED;                left_rotate(z-&gt;p()-&gt;p());            }        }    }    _root-&gt;color() = BLACK;}    template&lt;class T&gt;void BinTree&lt;T&gt;::insert(BinNode&lt;T&gt;* node){    BinNode&lt;T&gt;* y = nil;    BinNode&lt;T&gt;* x= _root;;    while (x != nil)    {        y = x;        if(node-&gt;data() &lt; x-&gt;data())        {            x = x-&gt;lc();        }        else        {            x = x-&gt;rc();        }    }    node-&gt;p() = y;    if (y == nil )    {        _root = node;    }    else if(node-&gt;data() &lt; y-&gt;data())    {        y-&gt;lc() = node;    }    else    {        y-&gt;rc() = node;    }    node-&gt;lc() = nil;    node-&gt;rc() = nil;    node-&gt;color() = RED;    //std::cout&lt;&lt;\"before insert_fixup \"&lt;&lt;std::endl;    //bfs();    //std::cout&lt;&lt;\"===================\"&lt;&lt;std::endl;    insert_fixup(node);}#endif /* ifndef __RED_BLACK_TREE_H__*/</code></pre>",
            "url": "http://localhost:4000/2020/01/03/redblacktre",
            
            
            
            
            
            "date_published": "2020-01-03T00:00:00+08:00",
            "date_modified": "2020-01-03T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>"lingjiey@gmail.com", "url"=>nil}"
                
            
        }
    
    ]
}