<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="C.Sereja and Brackets" /><meta property="og:locale" content="en_US" /><meta name="description" content="趁热打铁，深入理解segment tree算法。参考文章链接。" /><meta property="og:description" content="趁热打铁，深入理解segment tree算法。参考文章链接。" /><link rel="canonical" href="http://localhost:4000/2020/01/19/sereja-and-brackets" /><meta property="og:url" content="http://localhost:4000/2020/01/19/sereja-and-brackets" /><meta property="og:site_name" content="只砖片瓦" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-01-19T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C.Sereja and Brackets" /><meta name="twitter:site" content="@" /> <script type="application/ld+json"> {"headline":"C.Sereja and Brackets","dateModified":"2020-01-19T00:00:00+08:00","datePublished":"2020-01-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/01/19/sereja-and-brackets"},"url":"http://localhost:4000/2020/01/19/sereja-and-brackets","description":"趁热打铁，深入理解segment tree算法。参考文章链接。","@type":"BlogPosting","@context":"https://schema.org"}</script><title> C.Sereja and Brackets - 只砖片瓦</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="只砖片瓦" href="/atom.xml"><link rel="alternate" type="application/json" title="只砖片瓦" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}.entry-content{margin:10px 0}figcaption{font-size:smaller}.entry-header{margin:1px 0 10px 0;border:0;color:#000000;font-family:Arial, sans-serif;font-size:medium;line-height:normal;text-align:left;font-weight:bold}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">只砖片瓦</h1>--><nav role="navigation"><ul><li> <a href="/" >Writing</a></li><li> <a href="/about" >About</a></li><li> <a href="/search" >Search</a></li><li> <a href="/categories" >Categories</a></li></ul></nav></header><section class="post"><h2>C.Sereja and Brackets</h2><p>趁热打铁，深入理解segment tree算法。参考文章<a href="https://codeforces.com/blog/entry/15890">链接</a>。</p><h2 id="问题描述">问题描述</h2><blockquote><p>Sereja has a bracket sequence s1, s2, …, sn, or, in other words, a string s of length n, consisting of characters “(“ and “)”.</p><p>Sereja needs to answer m queries, each of them is described by two integers li, ri (1 ≤ li ≤ ri ≤ n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence sli, sli + 1, …, sri. Help Sereja answer all queries.</p><p>You can find the definitions for a subsequence and a correct bracket sequence in the notes.</p><p>Input The first line contains a sequence of characters s1, s2, …, sn (1 ≤ n ≤ 106) without any spaces. Each character is either a “(“ or a “)”. The second line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 ≤ li ≤ ri ≤ n) — the description of the i-th query.</p><p>Output Print the answer to each question on a single line. Print the answers in the order they go in the input.</p></blockquote><h2 id="解答">解答</h2><p>首先，我们看下标准的segment tree函数:</p><pre><code>void build(int id =1, int l =0, int r = n)
{
    if(r - l&lt; 2)
    {
        s[id]= a[l];
        return;
    }
    int mid = (l + r)/2;
    build(id *2 , l ,mid);
    build(id*2+1,mid,r);
    s[id] = s[id *2] + s[id*2 +1];
}
int sum(int x, int y, int id=1, int l =0, int r=n)
{
    if(x &gt;=r || l&gt;=y) return 0;
    if(x&lt;=l &amp;&amp;  r &lt;= y) return s[id];
    int mid =(l + r)/2;
    return sum(x,y,id*2,l, mid)
    + sum(x,y,id*2+1,mid,r);
}
vector&lt;s&gt;;
void split(int x, int y,int n)
{
    int l = x;
    int r = y;
    for(l +=n, r+=n ; l&lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)
    {
        if(l&amp;1) s.push_back(l++);
        if(r&amp;1) s.push_back(--r);
    }
}
</code></pre><p>我们通过完全二叉树储存区间，查询的时候，查询这个区间的最大子节点所储存的值。</p><p>这里同样，为了实现括号配对，我们对每个节点储存三种数据:</p><ul><li>t[x], x节点所有的配对的数目;</li><li>o[x], x节点所代表的区间上，未配对的左括号数；</li><li>c[x], x节点所代表的区间上,为配对的右括号数；</li></ul><p>而每次合并子节点时：</p><pre><code>tmp = min(o[2*x], c[2*x +1])
t[x] = t[2*x] + t[2*x + 1] + tmp
o[x] = o[2*x] + o[2*x +1] - tmp
c[x] = c[2*x] + c[2*x + 1] - tmp
</code></pre><p>类似的，我们可以得出build函数：</p><pre><code>void update(int id)
{
    int tmp = min(o[2*id], c[2*id +1]);
    t[id] = t[2*id] + t[2*id + 1] + tmp;
    o[id] = o[2*id] + o[2*id +1] - tmp;
    c[id] = c[2*id] + c[2*id + 1] - tmp;
}
void build(int id = 1, int l = 0, int r = n)
{
    if(r - l &lt; 2)
    {
        if(s[l] == '(')
        {
            o[l] = 1;
        }
        else
        {
            c[l] = 1;
        }
        return;
    }
    int mid = ( l + r) /2;
    build(2 * id,l,mid);
    build(2 * id +1,mid, r);
    update(id);
}

</code></pre><p>对应的查询函数：</p><pre><code>typedef pair&lt;int, int&gt;pii;
typedef pair&lt;int,pii&gt; node;
node segment(int x, int y,int id=1, int l =0, int r = n)
{
    if( l&gt;= y || x &gt;= r) return node(0,pii(0,0));
    if(x &lt;= l &amp;&amp; r&lt;= y)
    {
        return node(t[id], pii(o[id],c[id]));
    }
    int mid = (l + r)/2;
    node a = segment(x, y, 2 * id, l, mid);
    node b = segment(x,y,2*id + 1,mid,r);
    int temp = min(a.y.x,b.y.y);
    int T = a.x + b.x + temp;
    int O = a.y.x + b.y.x - temp;
    int C = a.y.y + b.y.y - temp;
    return node(T,pii(O,C));
}
</code></pre><p>完工。</p><span class="meta"><time datetime="2020-01-19T00:00:00+08:00">January 19, 2020</time> &middot; <a href="/tag/algorithm">algorithm</a></span> <!--<span class="meta"><time datetime="2020-01-19T00:00:00+08:00">January 19, 2020</time> &middot; <a class="post" href="/tag/algorithm">algorithm</a></span> --></section></main></body></html>
